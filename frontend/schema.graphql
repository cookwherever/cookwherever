# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"columns and relationships of \"food\""
type food {
    data_type: food_data_type_enum
    description: String
    description_tsv: tsvector
    fdc_id: Int!
    "An array relationship"
    food_attributes(
        "distinct select on columns"
        distinct_on: [food_attribute_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_attribute_order_by!],
        "filter the rows returned"
        where: food_attribute_bool_exp
    ): [food_attribute!]!
    "An aggregate relationship"
    food_attributes_aggregate(
        "distinct select on columns"
        distinct_on: [food_attribute_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_attribute_order_by!],
        "filter the rows returned"
        where: food_attribute_bool_exp
    ): food_attribute_aggregate!
    "An object relationship"
    food_category: food_category
    food_category_id: Int
    "An array relationship"
    food_nutrients(
        "distinct select on columns"
        distinct_on: [food_nutrient_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_nutrient_order_by!],
        "filter the rows returned"
        where: food_nutrient_bool_exp
    ): [food_nutrient!]!
    "An aggregate relationship"
    food_nutrients_aggregate(
        "distinct select on columns"
        distinct_on: [food_nutrient_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_nutrient_order_by!],
        "filter the rows returned"
        where: food_nutrient_bool_exp
    ): food_nutrient_aggregate!
    "An array relationship"
    food_portions(
        "distinct select on columns"
        distinct_on: [food_portion_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_portion_order_by!],
        "filter the rows returned"
        where: food_portion_bool_exp
    ): [food_portion!]!
    "An aggregate relationship"
    food_portions_aggregate(
        "distinct select on columns"
        distinct_on: [food_portion_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_portion_order_by!],
        "filter the rows returned"
        where: food_portion_bool_exp
    ): food_portion_aggregate!
    publication_date: timestamp
}

"aggregated selection of \"food\""
type food_aggregate {
    aggregate: food_aggregate_fields
    nodes: [food!]!
}

"aggregate fields of \"food\""
type food_aggregate_fields {
    avg: food_avg_fields
    count(columns: [food_select_column!], distinct: Boolean): Int!
    max: food_max_fields
    min: food_min_fields
    stddev: food_stddev_fields
    stddev_pop: food_stddev_pop_fields
    stddev_samp: food_stddev_samp_fields
    sum: food_sum_fields
    var_pop: food_var_pop_fields
    var_samp: food_var_samp_fields
    variance: food_variance_fields
}

"columns and relationships of \"food_attribute\""
type food_attribute {
    fdc_id: Int
    "An object relationship"
    food_attribute_type: food_attribute_type
    food_attribute_type_id: Int
    id: Int!
    name: String
    seq_num: Int
    value: String
}

"aggregated selection of \"food_attribute\""
type food_attribute_aggregate {
    aggregate: food_attribute_aggregate_fields
    nodes: [food_attribute!]!
}

"aggregate fields of \"food_attribute\""
type food_attribute_aggregate_fields {
    avg: food_attribute_avg_fields
    count(columns: [food_attribute_select_column!], distinct: Boolean): Int!
    max: food_attribute_max_fields
    min: food_attribute_min_fields
    stddev: food_attribute_stddev_fields
    stddev_pop: food_attribute_stddev_pop_fields
    stddev_samp: food_attribute_stddev_samp_fields
    sum: food_attribute_sum_fields
    var_pop: food_attribute_var_pop_fields
    var_samp: food_attribute_var_samp_fields
    variance: food_attribute_variance_fields
}

"aggregate avg on columns"
type food_attribute_avg_fields {
    fdc_id: Float
    food_attribute_type_id: Float
    id: Float
    seq_num: Float
}

"aggregate max on columns"
type food_attribute_max_fields {
    fdc_id: Int
    food_attribute_type_id: Int
    id: Int
    name: String
    seq_num: Int
    value: String
}

"aggregate min on columns"
type food_attribute_min_fields {
    fdc_id: Int
    food_attribute_type_id: Int
    id: Int
    name: String
    seq_num: Int
    value: String
}

"response of any mutation on the table \"food_attribute\""
type food_attribute_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [food_attribute!]!
}

"aggregate stddev on columns"
type food_attribute_stddev_fields {
    fdc_id: Float
    food_attribute_type_id: Float
    id: Float
    seq_num: Float
}

"aggregate stddev_pop on columns"
type food_attribute_stddev_pop_fields {
    fdc_id: Float
    food_attribute_type_id: Float
    id: Float
    seq_num: Float
}

"aggregate stddev_samp on columns"
type food_attribute_stddev_samp_fields {
    fdc_id: Float
    food_attribute_type_id: Float
    id: Float
    seq_num: Float
}

"aggregate sum on columns"
type food_attribute_sum_fields {
    fdc_id: Int
    food_attribute_type_id: Int
    id: Int
    seq_num: Int
}

"columns and relationships of \"food_attribute_type\""
type food_attribute_type {
    description: String
    id: Int!
    name: String
}

"aggregated selection of \"food_attribute_type\""
type food_attribute_type_aggregate {
    aggregate: food_attribute_type_aggregate_fields
    nodes: [food_attribute_type!]!
}

"aggregate fields of \"food_attribute_type\""
type food_attribute_type_aggregate_fields {
    avg: food_attribute_type_avg_fields
    count(columns: [food_attribute_type_select_column!], distinct: Boolean): Int!
    max: food_attribute_type_max_fields
    min: food_attribute_type_min_fields
    stddev: food_attribute_type_stddev_fields
    stddev_pop: food_attribute_type_stddev_pop_fields
    stddev_samp: food_attribute_type_stddev_samp_fields
    sum: food_attribute_type_sum_fields
    var_pop: food_attribute_type_var_pop_fields
    var_samp: food_attribute_type_var_samp_fields
    variance: food_attribute_type_variance_fields
}

"aggregate avg on columns"
type food_attribute_type_avg_fields {
    id: Float
}

"aggregate max on columns"
type food_attribute_type_max_fields {
    description: String
    id: Int
    name: String
}

"aggregate min on columns"
type food_attribute_type_min_fields {
    description: String
    id: Int
    name: String
}

"response of any mutation on the table \"food_attribute_type\""
type food_attribute_type_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [food_attribute_type!]!
}

"aggregate stddev on columns"
type food_attribute_type_stddev_fields {
    id: Float
}

"aggregate stddev_pop on columns"
type food_attribute_type_stddev_pop_fields {
    id: Float
}

"aggregate stddev_samp on columns"
type food_attribute_type_stddev_samp_fields {
    id: Float
}

"aggregate sum on columns"
type food_attribute_type_sum_fields {
    id: Int
}

"aggregate var_pop on columns"
type food_attribute_type_var_pop_fields {
    id: Float
}

"aggregate var_samp on columns"
type food_attribute_type_var_samp_fields {
    id: Float
}

"aggregate variance on columns"
type food_attribute_type_variance_fields {
    id: Float
}

"aggregate var_pop on columns"
type food_attribute_var_pop_fields {
    fdc_id: Float
    food_attribute_type_id: Float
    id: Float
    seq_num: Float
}

"aggregate var_samp on columns"
type food_attribute_var_samp_fields {
    fdc_id: Float
    food_attribute_type_id: Float
    id: Float
    seq_num: Float
}

"aggregate variance on columns"
type food_attribute_variance_fields {
    fdc_id: Float
    food_attribute_type_id: Float
    id: Float
    seq_num: Float
}

"aggregate avg on columns"
type food_avg_fields {
    fdc_id: Float
    food_category_id: Float
}

"columns and relationships of \"food_category\""
type food_category {
    code: Int
    description: String
    id: Int!
}

"aggregated selection of \"food_category\""
type food_category_aggregate {
    aggregate: food_category_aggregate_fields
    nodes: [food_category!]!
}

"aggregate fields of \"food_category\""
type food_category_aggregate_fields {
    avg: food_category_avg_fields
    count(columns: [food_category_select_column!], distinct: Boolean): Int!
    max: food_category_max_fields
    min: food_category_min_fields
    stddev: food_category_stddev_fields
    stddev_pop: food_category_stddev_pop_fields
    stddev_samp: food_category_stddev_samp_fields
    sum: food_category_sum_fields
    var_pop: food_category_var_pop_fields
    var_samp: food_category_var_samp_fields
    variance: food_category_variance_fields
}

"aggregate avg on columns"
type food_category_avg_fields {
    code: Float
    id: Float
}

"aggregate max on columns"
type food_category_max_fields {
    code: Int
    description: String
    id: Int
}

"aggregate min on columns"
type food_category_min_fields {
    code: Int
    description: String
    id: Int
}

"response of any mutation on the table \"food_category\""
type food_category_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [food_category!]!
}

"aggregate stddev on columns"
type food_category_stddev_fields {
    code: Float
    id: Float
}

"aggregate stddev_pop on columns"
type food_category_stddev_pop_fields {
    code: Float
    id: Float
}

"aggregate stddev_samp on columns"
type food_category_stddev_samp_fields {
    code: Float
    id: Float
}

"aggregate sum on columns"
type food_category_sum_fields {
    code: Int
    id: Int
}

"aggregate var_pop on columns"
type food_category_var_pop_fields {
    code: Float
    id: Float
}

"aggregate var_samp on columns"
type food_category_var_samp_fields {
    code: Float
    id: Float
}

"aggregate variance on columns"
type food_category_variance_fields {
    code: Float
    id: Float
}

"aggregate max on columns"
type food_max_fields {
    description: String
    fdc_id: Int
    food_category_id: Int
    publication_date: timestamp
}

"aggregate min on columns"
type food_min_fields {
    description: String
    fdc_id: Int
    food_category_id: Int
    publication_date: timestamp
}

"response of any mutation on the table \"food\""
type food_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [food!]!
}

"columns and relationships of \"food_nutrient\""
type food_nutrient {
    amount: float8
    data_points: Int
    derivation_id: Int
    fdc_id: Int
    footnote: String
    id: Int!
    max: float8
    median: float8
    min: float8
    min_year_acquired: Int
    "An object relationship"
    nutrient: nutrient
    nutrient_id: Int
}

"aggregated selection of \"food_nutrient\""
type food_nutrient_aggregate {
    aggregate: food_nutrient_aggregate_fields
    nodes: [food_nutrient!]!
}

"aggregate fields of \"food_nutrient\""
type food_nutrient_aggregate_fields {
    avg: food_nutrient_avg_fields
    count(columns: [food_nutrient_select_column!], distinct: Boolean): Int!
    max: food_nutrient_max_fields
    min: food_nutrient_min_fields
    stddev: food_nutrient_stddev_fields
    stddev_pop: food_nutrient_stddev_pop_fields
    stddev_samp: food_nutrient_stddev_samp_fields
    sum: food_nutrient_sum_fields
    var_pop: food_nutrient_var_pop_fields
    var_samp: food_nutrient_var_samp_fields
    variance: food_nutrient_variance_fields
}

"aggregate avg on columns"
type food_nutrient_avg_fields {
    amount: Float
    data_points: Float
    derivation_id: Float
    fdc_id: Float
    id: Float
    max: Float
    median: Float
    min: Float
    min_year_acquired: Float
    nutrient_id: Float
}

"aggregate max on columns"
type food_nutrient_max_fields {
    amount: float8
    data_points: Int
    derivation_id: Int
    fdc_id: Int
    footnote: String
    id: Int
    max: float8
    median: float8
    min: float8
    min_year_acquired: Int
    nutrient_id: Int
}

"aggregate min on columns"
type food_nutrient_min_fields {
    amount: float8
    data_points: Int
    derivation_id: Int
    fdc_id: Int
    footnote: String
    id: Int
    max: float8
    median: float8
    min: float8
    min_year_acquired: Int
    nutrient_id: Int
}

"response of any mutation on the table \"food_nutrient\""
type food_nutrient_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [food_nutrient!]!
}

"aggregate stddev on columns"
type food_nutrient_stddev_fields {
    amount: Float
    data_points: Float
    derivation_id: Float
    fdc_id: Float
    id: Float
    max: Float
    median: Float
    min: Float
    min_year_acquired: Float
    nutrient_id: Float
}

"aggregate stddev_pop on columns"
type food_nutrient_stddev_pop_fields {
    amount: Float
    data_points: Float
    derivation_id: Float
    fdc_id: Float
    id: Float
    max: Float
    median: Float
    min: Float
    min_year_acquired: Float
    nutrient_id: Float
}

"aggregate stddev_samp on columns"
type food_nutrient_stddev_samp_fields {
    amount: Float
    data_points: Float
    derivation_id: Float
    fdc_id: Float
    id: Float
    max: Float
    median: Float
    min: Float
    min_year_acquired: Float
    nutrient_id: Float
}

"aggregate sum on columns"
type food_nutrient_sum_fields {
    amount: float8
    data_points: Int
    derivation_id: Int
    fdc_id: Int
    id: Int
    max: float8
    median: float8
    min: float8
    min_year_acquired: Int
    nutrient_id: Int
}

"aggregate var_pop on columns"
type food_nutrient_var_pop_fields {
    amount: Float
    data_points: Float
    derivation_id: Float
    fdc_id: Float
    id: Float
    max: Float
    median: Float
    min: Float
    min_year_acquired: Float
    nutrient_id: Float
}

"aggregate var_samp on columns"
type food_nutrient_var_samp_fields {
    amount: Float
    data_points: Float
    derivation_id: Float
    fdc_id: Float
    id: Float
    max: Float
    median: Float
    min: Float
    min_year_acquired: Float
    nutrient_id: Float
}

"aggregate variance on columns"
type food_nutrient_variance_fields {
    amount: Float
    data_points: Float
    derivation_id: Float
    fdc_id: Float
    id: Float
    max: Float
    median: Float
    min: Float
    min_year_acquired: Float
    nutrient_id: Float
}

"columns and relationships of \"food_portion\""
type food_portion {
    amount: float8
    data_points: Int
    fdc_id: Int
    footnote: String
    gram_weight: float8
    id: Int!
    "An object relationship"
    measure_unit: measure_unit
    measure_unit_id: Int
    min_year_acquired: Int
    modifier: String
    portion_description: String
    seq_num: Int
}

"aggregated selection of \"food_portion\""
type food_portion_aggregate {
    aggregate: food_portion_aggregate_fields
    nodes: [food_portion!]!
}

"aggregate fields of \"food_portion\""
type food_portion_aggregate_fields {
    avg: food_portion_avg_fields
    count(columns: [food_portion_select_column!], distinct: Boolean): Int!
    max: food_portion_max_fields
    min: food_portion_min_fields
    stddev: food_portion_stddev_fields
    stddev_pop: food_portion_stddev_pop_fields
    stddev_samp: food_portion_stddev_samp_fields
    sum: food_portion_sum_fields
    var_pop: food_portion_var_pop_fields
    var_samp: food_portion_var_samp_fields
    variance: food_portion_variance_fields
}

"aggregate avg on columns"
type food_portion_avg_fields {
    amount: Float
    data_points: Float
    fdc_id: Float
    gram_weight: Float
    id: Float
    measure_unit_id: Float
    min_year_acquired: Float
    seq_num: Float
}

"aggregate max on columns"
type food_portion_max_fields {
    amount: float8
    data_points: Int
    fdc_id: Int
    footnote: String
    gram_weight: float8
    id: Int
    measure_unit_id: Int
    min_year_acquired: Int
    modifier: String
    portion_description: String
    seq_num: Int
}

"aggregate min on columns"
type food_portion_min_fields {
    amount: float8
    data_points: Int
    fdc_id: Int
    footnote: String
    gram_weight: float8
    id: Int
    measure_unit_id: Int
    min_year_acquired: Int
    modifier: String
    portion_description: String
    seq_num: Int
}

"response of any mutation on the table \"food_portion\""
type food_portion_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [food_portion!]!
}

"aggregate stddev on columns"
type food_portion_stddev_fields {
    amount: Float
    data_points: Float
    fdc_id: Float
    gram_weight: Float
    id: Float
    measure_unit_id: Float
    min_year_acquired: Float
    seq_num: Float
}

"aggregate stddev_pop on columns"
type food_portion_stddev_pop_fields {
    amount: Float
    data_points: Float
    fdc_id: Float
    gram_weight: Float
    id: Float
    measure_unit_id: Float
    min_year_acquired: Float
    seq_num: Float
}

"aggregate stddev_samp on columns"
type food_portion_stddev_samp_fields {
    amount: Float
    data_points: Float
    fdc_id: Float
    gram_weight: Float
    id: Float
    measure_unit_id: Float
    min_year_acquired: Float
    seq_num: Float
}

"aggregate sum on columns"
type food_portion_sum_fields {
    amount: float8
    data_points: Int
    fdc_id: Int
    gram_weight: float8
    id: Int
    measure_unit_id: Int
    min_year_acquired: Int
    seq_num: Int
}

"aggregate var_pop on columns"
type food_portion_var_pop_fields {
    amount: Float
    data_points: Float
    fdc_id: Float
    gram_weight: Float
    id: Float
    measure_unit_id: Float
    min_year_acquired: Float
    seq_num: Float
}

"aggregate var_samp on columns"
type food_portion_var_samp_fields {
    amount: Float
    data_points: Float
    fdc_id: Float
    gram_weight: Float
    id: Float
    measure_unit_id: Float
    min_year_acquired: Float
    seq_num: Float
}

"aggregate variance on columns"
type food_portion_variance_fields {
    amount: Float
    data_points: Float
    fdc_id: Float
    gram_weight: Float
    id: Float
    measure_unit_id: Float
    min_year_acquired: Float
    seq_num: Float
}

"aggregate stddev on columns"
type food_stddev_fields {
    fdc_id: Float
    food_category_id: Float
}

"aggregate stddev_pop on columns"
type food_stddev_pop_fields {
    fdc_id: Float
    food_category_id: Float
}

"aggregate stddev_samp on columns"
type food_stddev_samp_fields {
    fdc_id: Float
    food_category_id: Float
}

"aggregate sum on columns"
type food_sum_fields {
    fdc_id: Int
    food_category_id: Int
}

"aggregate var_pop on columns"
type food_var_pop_fields {
    fdc_id: Float
    food_category_id: Float
}

"aggregate var_samp on columns"
type food_var_samp_fields {
    fdc_id: Float
    food_category_id: Float
}

"aggregate variance on columns"
type food_variance_fields {
    fdc_id: Float
    food_category_id: Float
}

"columns and relationships of \"measure_unit\""
type measure_unit {
    id: Int!
    ml: float8
    name: String
}

"aggregated selection of \"measure_unit\""
type measure_unit_aggregate {
    aggregate: measure_unit_aggregate_fields
    nodes: [measure_unit!]!
}

"aggregate fields of \"measure_unit\""
type measure_unit_aggregate_fields {
    avg: measure_unit_avg_fields
    count(columns: [measure_unit_select_column!], distinct: Boolean): Int!
    max: measure_unit_max_fields
    min: measure_unit_min_fields
    stddev: measure_unit_stddev_fields
    stddev_pop: measure_unit_stddev_pop_fields
    stddev_samp: measure_unit_stddev_samp_fields
    sum: measure_unit_sum_fields
    var_pop: measure_unit_var_pop_fields
    var_samp: measure_unit_var_samp_fields
    variance: measure_unit_variance_fields
}

"aggregate avg on columns"
type measure_unit_avg_fields {
    id: Float
    ml: Float
}

"aggregate max on columns"
type measure_unit_max_fields {
    id: Int
    ml: float8
    name: String
}

"aggregate min on columns"
type measure_unit_min_fields {
    id: Int
    ml: float8
    name: String
}

"response of any mutation on the table \"measure_unit\""
type measure_unit_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [measure_unit!]!
}

"aggregate stddev on columns"
type measure_unit_stddev_fields {
    id: Float
    ml: Float
}

"aggregate stddev_pop on columns"
type measure_unit_stddev_pop_fields {
    id: Float
    ml: Float
}

"aggregate stddev_samp on columns"
type measure_unit_stddev_samp_fields {
    id: Float
    ml: Float
}

"aggregate sum on columns"
type measure_unit_sum_fields {
    id: Int
    ml: float8
}

"aggregate var_pop on columns"
type measure_unit_var_pop_fields {
    id: Float
    ml: Float
}

"aggregate var_samp on columns"
type measure_unit_var_samp_fields {
    id: Float
    ml: Float
}

"aggregate variance on columns"
type measure_unit_variance_fields {
    id: Float
    ml: Float
}

"mutation root"
type mutation_root {
    "delete data from the table: \"food\""
    delete_food(
        "filter the rows which have to be deleted"
        where: food_bool_exp!
    ): food_mutation_response
    "delete data from the table: \"food_attribute\""
    delete_food_attribute(
        "filter the rows which have to be deleted"
        where: food_attribute_bool_exp!
    ): food_attribute_mutation_response
    "delete single row from the table: \"food_attribute\""
    delete_food_attribute_by_pk(id: Int!): food_attribute
    "delete data from the table: \"food_attribute_type\""
    delete_food_attribute_type(
        "filter the rows which have to be deleted"
        where: food_attribute_type_bool_exp!
    ): food_attribute_type_mutation_response
    "delete single row from the table: \"food_attribute_type\""
    delete_food_attribute_type_by_pk(id: Int!): food_attribute_type
    "delete single row from the table: \"food\""
    delete_food_by_pk(fdc_id: Int!): food
    "delete data from the table: \"food_category\""
    delete_food_category(
        "filter the rows which have to be deleted"
        where: food_category_bool_exp!
    ): food_category_mutation_response
    "delete single row from the table: \"food_category\""
    delete_food_category_by_pk(id: Int!): food_category
    "delete data from the table: \"food_nutrient\""
    delete_food_nutrient(
        "filter the rows which have to be deleted"
        where: food_nutrient_bool_exp!
    ): food_nutrient_mutation_response
    "delete single row from the table: \"food_nutrient\""
    delete_food_nutrient_by_pk(id: Int!): food_nutrient
    "delete data from the table: \"food_portion\""
    delete_food_portion(
        "filter the rows which have to be deleted"
        where: food_portion_bool_exp!
    ): food_portion_mutation_response
    "delete single row from the table: \"food_portion\""
    delete_food_portion_by_pk(id: Int!): food_portion
    "delete data from the table: \"measure_unit\""
    delete_measure_unit(
        "filter the rows which have to be deleted"
        where: measure_unit_bool_exp!
    ): measure_unit_mutation_response
    "delete single row from the table: \"measure_unit\""
    delete_measure_unit_by_pk(id: Int!): measure_unit
    "delete data from the table: \"nutrient\""
    delete_nutrient(
        "filter the rows which have to be deleted"
        where: nutrient_bool_exp!
    ): nutrient_mutation_response
    "delete single row from the table: \"nutrient\""
    delete_nutrient_by_pk(id: Int!): nutrient
    "delete data from the table: \"recipe_direction_durations\""
    delete_recipe_direction_durations(
        "filter the rows which have to be deleted"
        where: recipe_direction_durations_bool_exp!
    ): recipe_direction_durations_mutation_response
    "delete single row from the table: \"recipe_direction_durations\""
    delete_recipe_direction_durations_by_pk(id: Int!): recipe_direction_durations
    "delete data from the table: \"recipe_directions\""
    delete_recipe_directions(
        "filter the rows which have to be deleted"
        where: recipe_directions_bool_exp!
    ): recipe_directions_mutation_response
    "delete single row from the table: \"recipe_directions\""
    delete_recipe_directions_by_pk(id: Int!): recipe_directions
    "delete data from the table: \"recipe_ingredient_food_candidate\""
    delete_recipe_ingredient_food_candidate(
        "filter the rows which have to be deleted"
        where: recipe_ingredient_food_candidate_bool_exp!
    ): recipe_ingredient_food_candidate_mutation_response
    "delete single row from the table: \"recipe_ingredient_food_candidate\""
    delete_recipe_ingredient_food_candidate_by_pk(id: Int!): recipe_ingredient_food_candidate
    "delete data from the table: \"recipe_ingredient_groups\""
    delete_recipe_ingredient_groups(
        "filter the rows which have to be deleted"
        where: recipe_ingredient_groups_bool_exp!
    ): recipe_ingredient_groups_mutation_response
    "delete single row from the table: \"recipe_ingredient_groups\""
    delete_recipe_ingredient_groups_by_pk(id: Int!): recipe_ingredient_groups
    "delete data from the table: \"recipe_ingredients\""
    delete_recipe_ingredients(
        "filter the rows which have to be deleted"
        where: recipe_ingredients_bool_exp!
    ): recipe_ingredients_mutation_response
    "delete single row from the table: \"recipe_ingredients\""
    delete_recipe_ingredients_by_pk(id: Int!): recipe_ingredients
    "delete data from the table: \"recipe_queues\""
    delete_recipe_queues(
        "filter the rows which have to be deleted"
        where: recipe_queues_bool_exp!
    ): recipe_queues_mutation_response
    "delete single row from the table: \"recipe_queues\""
    delete_recipe_queues_by_pk(id: Int!): recipe_queues
    "delete data from the table: \"recipe_tags\""
    delete_recipe_tags(
        "filter the rows which have to be deleted"
        where: recipe_tags_bool_exp!
    ): recipe_tags_mutation_response
    "delete single row from the table: \"recipe_tags\""
    delete_recipe_tags_by_pk(id: Int!): recipe_tags
    "delete data from the table: \"recipes\""
    delete_recipes(
        "filter the rows which have to be deleted"
        where: recipes_bool_exp!
    ): recipes_mutation_response
    "delete single row from the table: \"recipes\""
    delete_recipes_by_pk(id: Int!): recipes
    "insert data into the table: \"food\""
    insert_food(
        "the rows to be inserted"
        objects: [food_insert_input!]!,
        "on conflict condition"
        on_conflict: food_on_conflict
    ): food_mutation_response
    "insert data into the table: \"food_attribute\""
    insert_food_attribute(
        "the rows to be inserted"
        objects: [food_attribute_insert_input!]!,
        "on conflict condition"
        on_conflict: food_attribute_on_conflict
    ): food_attribute_mutation_response
    "insert a single row into the table: \"food_attribute\""
    insert_food_attribute_one(
        "the row to be inserted"
        object: food_attribute_insert_input!,
        "on conflict condition"
        on_conflict: food_attribute_on_conflict
    ): food_attribute
    "insert data into the table: \"food_attribute_type\""
    insert_food_attribute_type(
        "the rows to be inserted"
        objects: [food_attribute_type_insert_input!]!,
        "on conflict condition"
        on_conflict: food_attribute_type_on_conflict
    ): food_attribute_type_mutation_response
    "insert a single row into the table: \"food_attribute_type\""
    insert_food_attribute_type_one(
        "the row to be inserted"
        object: food_attribute_type_insert_input!,
        "on conflict condition"
        on_conflict: food_attribute_type_on_conflict
    ): food_attribute_type
    "insert data into the table: \"food_category\""
    insert_food_category(
        "the rows to be inserted"
        objects: [food_category_insert_input!]!,
        "on conflict condition"
        on_conflict: food_category_on_conflict
    ): food_category_mutation_response
    "insert a single row into the table: \"food_category\""
    insert_food_category_one(
        "the row to be inserted"
        object: food_category_insert_input!,
        "on conflict condition"
        on_conflict: food_category_on_conflict
    ): food_category
    "insert data into the table: \"food_nutrient\""
    insert_food_nutrient(
        "the rows to be inserted"
        objects: [food_nutrient_insert_input!]!,
        "on conflict condition"
        on_conflict: food_nutrient_on_conflict
    ): food_nutrient_mutation_response
    "insert a single row into the table: \"food_nutrient\""
    insert_food_nutrient_one(
        "the row to be inserted"
        object: food_nutrient_insert_input!,
        "on conflict condition"
        on_conflict: food_nutrient_on_conflict
    ): food_nutrient
    "insert a single row into the table: \"food\""
    insert_food_one(
        "the row to be inserted"
        object: food_insert_input!,
        "on conflict condition"
        on_conflict: food_on_conflict
    ): food
    "insert data into the table: \"food_portion\""
    insert_food_portion(
        "the rows to be inserted"
        objects: [food_portion_insert_input!]!,
        "on conflict condition"
        on_conflict: food_portion_on_conflict
    ): food_portion_mutation_response
    "insert a single row into the table: \"food_portion\""
    insert_food_portion_one(
        "the row to be inserted"
        object: food_portion_insert_input!,
        "on conflict condition"
        on_conflict: food_portion_on_conflict
    ): food_portion
    "insert data into the table: \"measure_unit\""
    insert_measure_unit(
        "the rows to be inserted"
        objects: [measure_unit_insert_input!]!,
        "on conflict condition"
        on_conflict: measure_unit_on_conflict
    ): measure_unit_mutation_response
    "insert a single row into the table: \"measure_unit\""
    insert_measure_unit_one(
        "the row to be inserted"
        object: measure_unit_insert_input!,
        "on conflict condition"
        on_conflict: measure_unit_on_conflict
    ): measure_unit
    "insert data into the table: \"nutrient\""
    insert_nutrient(
        "the rows to be inserted"
        objects: [nutrient_insert_input!]!,
        "on conflict condition"
        on_conflict: nutrient_on_conflict
    ): nutrient_mutation_response
    "insert a single row into the table: \"nutrient\""
    insert_nutrient_one(
        "the row to be inserted"
        object: nutrient_insert_input!,
        "on conflict condition"
        on_conflict: nutrient_on_conflict
    ): nutrient
    "insert data into the table: \"recipe_direction_durations\""
    insert_recipe_direction_durations(
        "the rows to be inserted"
        objects: [recipe_direction_durations_insert_input!]!,
        "on conflict condition"
        on_conflict: recipe_direction_durations_on_conflict
    ): recipe_direction_durations_mutation_response
    "insert a single row into the table: \"recipe_direction_durations\""
    insert_recipe_direction_durations_one(
        "the row to be inserted"
        object: recipe_direction_durations_insert_input!,
        "on conflict condition"
        on_conflict: recipe_direction_durations_on_conflict
    ): recipe_direction_durations
    "insert data into the table: \"recipe_directions\""
    insert_recipe_directions(
        "the rows to be inserted"
        objects: [recipe_directions_insert_input!]!,
        "on conflict condition"
        on_conflict: recipe_directions_on_conflict
    ): recipe_directions_mutation_response
    "insert a single row into the table: \"recipe_directions\""
    insert_recipe_directions_one(
        "the row to be inserted"
        object: recipe_directions_insert_input!,
        "on conflict condition"
        on_conflict: recipe_directions_on_conflict
    ): recipe_directions
    "insert data into the table: \"recipe_ingredient_food_candidate\""
    insert_recipe_ingredient_food_candidate(
        "the rows to be inserted"
        objects: [recipe_ingredient_food_candidate_insert_input!]!,
        "on conflict condition"
        on_conflict: recipe_ingredient_food_candidate_on_conflict
    ): recipe_ingredient_food_candidate_mutation_response
    "insert a single row into the table: \"recipe_ingredient_food_candidate\""
    insert_recipe_ingredient_food_candidate_one(
        "the row to be inserted"
        object: recipe_ingredient_food_candidate_insert_input!,
        "on conflict condition"
        on_conflict: recipe_ingredient_food_candidate_on_conflict
    ): recipe_ingredient_food_candidate
    "insert data into the table: \"recipe_ingredient_groups\""
    insert_recipe_ingredient_groups(
        "the rows to be inserted"
        objects: [recipe_ingredient_groups_insert_input!]!,
        "on conflict condition"
        on_conflict: recipe_ingredient_groups_on_conflict
    ): recipe_ingredient_groups_mutation_response
    "insert a single row into the table: \"recipe_ingredient_groups\""
    insert_recipe_ingredient_groups_one(
        "the row to be inserted"
        object: recipe_ingredient_groups_insert_input!,
        "on conflict condition"
        on_conflict: recipe_ingredient_groups_on_conflict
    ): recipe_ingredient_groups
    "insert data into the table: \"recipe_ingredients\""
    insert_recipe_ingredients(
        "the rows to be inserted"
        objects: [recipe_ingredients_insert_input!]!,
        "on conflict condition"
        on_conflict: recipe_ingredients_on_conflict
    ): recipe_ingredients_mutation_response
    "insert a single row into the table: \"recipe_ingredients\""
    insert_recipe_ingredients_one(
        "the row to be inserted"
        object: recipe_ingredients_insert_input!,
        "on conflict condition"
        on_conflict: recipe_ingredients_on_conflict
    ): recipe_ingredients
    "insert data into the table: \"recipe_queues\""
    insert_recipe_queues(
        "the rows to be inserted"
        objects: [recipe_queues_insert_input!]!,
        "on conflict condition"
        on_conflict: recipe_queues_on_conflict
    ): recipe_queues_mutation_response
    "insert a single row into the table: \"recipe_queues\""
    insert_recipe_queues_one(
        "the row to be inserted"
        object: recipe_queues_insert_input!,
        "on conflict condition"
        on_conflict: recipe_queues_on_conflict
    ): recipe_queues
    "insert data into the table: \"recipe_tags\""
    insert_recipe_tags(
        "the rows to be inserted"
        objects: [recipe_tags_insert_input!]!,
        "on conflict condition"
        on_conflict: recipe_tags_on_conflict
    ): recipe_tags_mutation_response
    "insert a single row into the table: \"recipe_tags\""
    insert_recipe_tags_one(
        "the row to be inserted"
        object: recipe_tags_insert_input!,
        "on conflict condition"
        on_conflict: recipe_tags_on_conflict
    ): recipe_tags
    "insert data into the table: \"recipes\""
    insert_recipes(
        "the rows to be inserted"
        objects: [recipes_insert_input!]!,
        "on conflict condition"
        on_conflict: recipes_on_conflict
    ): recipes_mutation_response
    "insert a single row into the table: \"recipes\""
    insert_recipes_one(
        "the row to be inserted"
        object: recipes_insert_input!,
        "on conflict condition"
        on_conflict: recipes_on_conflict
    ): recipes
    "update data of the table: \"food\""
    update_food(
        "increments the numeric columns with given value of the filtered values"
        _inc: food_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: food_set_input,
        "filter the rows which have to be updated"
        where: food_bool_exp!
    ): food_mutation_response
    "update data of the table: \"food_attribute\""
    update_food_attribute(
        "increments the numeric columns with given value of the filtered values"
        _inc: food_attribute_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: food_attribute_set_input,
        "filter the rows which have to be updated"
        where: food_attribute_bool_exp!
    ): food_attribute_mutation_response
    "update single row of the table: \"food_attribute\""
    update_food_attribute_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: food_attribute_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: food_attribute_set_input,
        pk_columns: food_attribute_pk_columns_input!
    ): food_attribute
    "update data of the table: \"food_attribute_type\""
    update_food_attribute_type(
        "increments the numeric columns with given value of the filtered values"
        _inc: food_attribute_type_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: food_attribute_type_set_input,
        "filter the rows which have to be updated"
        where: food_attribute_type_bool_exp!
    ): food_attribute_type_mutation_response
    "update single row of the table: \"food_attribute_type\""
    update_food_attribute_type_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: food_attribute_type_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: food_attribute_type_set_input,
        pk_columns: food_attribute_type_pk_columns_input!
    ): food_attribute_type
    "update single row of the table: \"food\""
    update_food_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: food_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: food_set_input,
        pk_columns: food_pk_columns_input!
    ): food
    "update data of the table: \"food_category\""
    update_food_category(
        "increments the numeric columns with given value of the filtered values"
        _inc: food_category_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: food_category_set_input,
        "filter the rows which have to be updated"
        where: food_category_bool_exp!
    ): food_category_mutation_response
    "update single row of the table: \"food_category\""
    update_food_category_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: food_category_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: food_category_set_input,
        pk_columns: food_category_pk_columns_input!
    ): food_category
    "update data of the table: \"food_nutrient\""
    update_food_nutrient(
        "increments the numeric columns with given value of the filtered values"
        _inc: food_nutrient_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: food_nutrient_set_input,
        "filter the rows which have to be updated"
        where: food_nutrient_bool_exp!
    ): food_nutrient_mutation_response
    "update single row of the table: \"food_nutrient\""
    update_food_nutrient_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: food_nutrient_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: food_nutrient_set_input,
        pk_columns: food_nutrient_pk_columns_input!
    ): food_nutrient
    "update data of the table: \"food_portion\""
    update_food_portion(
        "increments the numeric columns with given value of the filtered values"
        _inc: food_portion_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: food_portion_set_input,
        "filter the rows which have to be updated"
        where: food_portion_bool_exp!
    ): food_portion_mutation_response
    "update single row of the table: \"food_portion\""
    update_food_portion_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: food_portion_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: food_portion_set_input,
        pk_columns: food_portion_pk_columns_input!
    ): food_portion
    "update data of the table: \"measure_unit\""
    update_measure_unit(
        "increments the numeric columns with given value of the filtered values"
        _inc: measure_unit_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: measure_unit_set_input,
        "filter the rows which have to be updated"
        where: measure_unit_bool_exp!
    ): measure_unit_mutation_response
    "update single row of the table: \"measure_unit\""
    update_measure_unit_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: measure_unit_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: measure_unit_set_input,
        pk_columns: measure_unit_pk_columns_input!
    ): measure_unit
    "update data of the table: \"nutrient\""
    update_nutrient(
        "increments the numeric columns with given value of the filtered values"
        _inc: nutrient_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: nutrient_set_input,
        "filter the rows which have to be updated"
        where: nutrient_bool_exp!
    ): nutrient_mutation_response
    "update single row of the table: \"nutrient\""
    update_nutrient_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: nutrient_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: nutrient_set_input,
        pk_columns: nutrient_pk_columns_input!
    ): nutrient
    "update data of the table: \"recipe_direction_durations\""
    update_recipe_direction_durations(
        "increments the numeric columns with given value of the filtered values"
        _inc: recipe_direction_durations_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_direction_durations_set_input,
        "filter the rows which have to be updated"
        where: recipe_direction_durations_bool_exp!
    ): recipe_direction_durations_mutation_response
    "update single row of the table: \"recipe_direction_durations\""
    update_recipe_direction_durations_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: recipe_direction_durations_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_direction_durations_set_input,
        pk_columns: recipe_direction_durations_pk_columns_input!
    ): recipe_direction_durations
    "update data of the table: \"recipe_directions\""
    update_recipe_directions(
        "increments the numeric columns with given value of the filtered values"
        _inc: recipe_directions_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_directions_set_input,
        "filter the rows which have to be updated"
        where: recipe_directions_bool_exp!
    ): recipe_directions_mutation_response
    "update single row of the table: \"recipe_directions\""
    update_recipe_directions_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: recipe_directions_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_directions_set_input,
        pk_columns: recipe_directions_pk_columns_input!
    ): recipe_directions
    "update data of the table: \"recipe_ingredient_food_candidate\""
    update_recipe_ingredient_food_candidate(
        "increments the numeric columns with given value of the filtered values"
        _inc: recipe_ingredient_food_candidate_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_ingredient_food_candidate_set_input,
        "filter the rows which have to be updated"
        where: recipe_ingredient_food_candidate_bool_exp!
    ): recipe_ingredient_food_candidate_mutation_response
    "update single row of the table: \"recipe_ingredient_food_candidate\""
    update_recipe_ingredient_food_candidate_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: recipe_ingredient_food_candidate_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_ingredient_food_candidate_set_input,
        pk_columns: recipe_ingredient_food_candidate_pk_columns_input!
    ): recipe_ingredient_food_candidate
    "update data of the table: \"recipe_ingredient_groups\""
    update_recipe_ingredient_groups(
        "increments the numeric columns with given value of the filtered values"
        _inc: recipe_ingredient_groups_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_ingredient_groups_set_input,
        "filter the rows which have to be updated"
        where: recipe_ingredient_groups_bool_exp!
    ): recipe_ingredient_groups_mutation_response
    "update single row of the table: \"recipe_ingredient_groups\""
    update_recipe_ingredient_groups_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: recipe_ingredient_groups_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_ingredient_groups_set_input,
        pk_columns: recipe_ingredient_groups_pk_columns_input!
    ): recipe_ingredient_groups
    "update data of the table: \"recipe_ingredients\""
    update_recipe_ingredients(
        "increments the numeric columns with given value of the filtered values"
        _inc: recipe_ingredients_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_ingredients_set_input,
        "filter the rows which have to be updated"
        where: recipe_ingredients_bool_exp!
    ): recipe_ingredients_mutation_response
    "update single row of the table: \"recipe_ingredients\""
    update_recipe_ingredients_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: recipe_ingredients_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_ingredients_set_input,
        pk_columns: recipe_ingredients_pk_columns_input!
    ): recipe_ingredients
    "update data of the table: \"recipe_queues\""
    update_recipe_queues(
        "increments the numeric columns with given value of the filtered values"
        _inc: recipe_queues_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_queues_set_input,
        "filter the rows which have to be updated"
        where: recipe_queues_bool_exp!
    ): recipe_queues_mutation_response
    "update single row of the table: \"recipe_queues\""
    update_recipe_queues_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: recipe_queues_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_queues_set_input,
        pk_columns: recipe_queues_pk_columns_input!
    ): recipe_queues
    "update data of the table: \"recipe_tags\""
    update_recipe_tags(
        "increments the numeric columns with given value of the filtered values"
        _inc: recipe_tags_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_tags_set_input,
        "filter the rows which have to be updated"
        where: recipe_tags_bool_exp!
    ): recipe_tags_mutation_response
    "update single row of the table: \"recipe_tags\""
    update_recipe_tags_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: recipe_tags_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_tags_set_input,
        pk_columns: recipe_tags_pk_columns_input!
    ): recipe_tags
    "update data of the table: \"recipes\""
    update_recipes(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: recipes_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: recipes_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: recipes_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: recipes_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: recipes_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: recipes_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipes_set_input,
        "filter the rows which have to be updated"
        where: recipes_bool_exp!
    ): recipes_mutation_response
    "update single row of the table: \"recipes\""
    update_recipes_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: recipes_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: recipes_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: recipes_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: recipes_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: recipes_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: recipes_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipes_set_input,
        pk_columns: recipes_pk_columns_input!
    ): recipes
}

"columns and relationships of \"nutrient\""
type nutrient {
    id: Int!
    name: String
    nutrient_nbr: Int
    rank: Int
    unit_name: String
}

"aggregated selection of \"nutrient\""
type nutrient_aggregate {
    aggregate: nutrient_aggregate_fields
    nodes: [nutrient!]!
}

"aggregate fields of \"nutrient\""
type nutrient_aggregate_fields {
    avg: nutrient_avg_fields
    count(columns: [nutrient_select_column!], distinct: Boolean): Int!
    max: nutrient_max_fields
    min: nutrient_min_fields
    stddev: nutrient_stddev_fields
    stddev_pop: nutrient_stddev_pop_fields
    stddev_samp: nutrient_stddev_samp_fields
    sum: nutrient_sum_fields
    var_pop: nutrient_var_pop_fields
    var_samp: nutrient_var_samp_fields
    variance: nutrient_variance_fields
}

"aggregate avg on columns"
type nutrient_avg_fields {
    id: Float
    nutrient_nbr: Float
    rank: Float
}

"aggregate max on columns"
type nutrient_max_fields {
    id: Int
    name: String
    nutrient_nbr: Int
    rank: Int
    unit_name: String
}

"aggregate min on columns"
type nutrient_min_fields {
    id: Int
    name: String
    nutrient_nbr: Int
    rank: Int
    unit_name: String
}

"response of any mutation on the table \"nutrient\""
type nutrient_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [nutrient!]!
}

"aggregate stddev on columns"
type nutrient_stddev_fields {
    id: Float
    nutrient_nbr: Float
    rank: Float
}

"aggregate stddev_pop on columns"
type nutrient_stddev_pop_fields {
    id: Float
    nutrient_nbr: Float
    rank: Float
}

"aggregate stddev_samp on columns"
type nutrient_stddev_samp_fields {
    id: Float
    nutrient_nbr: Float
    rank: Float
}

"aggregate sum on columns"
type nutrient_sum_fields {
    id: Int
    nutrient_nbr: Int
    rank: Int
}

"aggregate var_pop on columns"
type nutrient_var_pop_fields {
    id: Float
    nutrient_nbr: Float
    rank: Float
}

"aggregate var_samp on columns"
type nutrient_var_samp_fields {
    id: Float
    nutrient_nbr: Float
    rank: Float
}

"aggregate variance on columns"
type nutrient_variance_fields {
    id: Float
    nutrient_nbr: Float
    rank: Float
}

type query_root {
    "fetch data from the table: \"food\""
    food(
        "distinct select on columns"
        distinct_on: [food_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_order_by!],
        "filter the rows returned"
        where: food_bool_exp
    ): [food!]!
    "fetch aggregated fields from the table: \"food\""
    food_aggregate(
        "distinct select on columns"
        distinct_on: [food_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_order_by!],
        "filter the rows returned"
        where: food_bool_exp
    ): food_aggregate!
    "fetch data from the table: \"food_attribute\""
    food_attribute(
        "distinct select on columns"
        distinct_on: [food_attribute_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_attribute_order_by!],
        "filter the rows returned"
        where: food_attribute_bool_exp
    ): [food_attribute!]!
    "fetch aggregated fields from the table: \"food_attribute\""
    food_attribute_aggregate(
        "distinct select on columns"
        distinct_on: [food_attribute_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_attribute_order_by!],
        "filter the rows returned"
        where: food_attribute_bool_exp
    ): food_attribute_aggregate!
    "fetch data from the table: \"food_attribute\" using primary key columns"
    food_attribute_by_pk(id: Int!): food_attribute
    "fetch data from the table: \"food_attribute_type\""
    food_attribute_type(
        "distinct select on columns"
        distinct_on: [food_attribute_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_attribute_type_order_by!],
        "filter the rows returned"
        where: food_attribute_type_bool_exp
    ): [food_attribute_type!]!
    "fetch aggregated fields from the table: \"food_attribute_type\""
    food_attribute_type_aggregate(
        "distinct select on columns"
        distinct_on: [food_attribute_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_attribute_type_order_by!],
        "filter the rows returned"
        where: food_attribute_type_bool_exp
    ): food_attribute_type_aggregate!
    "fetch data from the table: \"food_attribute_type\" using primary key columns"
    food_attribute_type_by_pk(id: Int!): food_attribute_type
    "fetch data from the table: \"food\" using primary key columns"
    food_by_pk(fdc_id: Int!): food
    "fetch data from the table: \"food_category\""
    food_category(
        "distinct select on columns"
        distinct_on: [food_category_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_category_order_by!],
        "filter the rows returned"
        where: food_category_bool_exp
    ): [food_category!]!
    "fetch aggregated fields from the table: \"food_category\""
    food_category_aggregate(
        "distinct select on columns"
        distinct_on: [food_category_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_category_order_by!],
        "filter the rows returned"
        where: food_category_bool_exp
    ): food_category_aggregate!
    "fetch data from the table: \"food_category\" using primary key columns"
    food_category_by_pk(id: Int!): food_category
    "fetch data from the table: \"food_nutrient\""
    food_nutrient(
        "distinct select on columns"
        distinct_on: [food_nutrient_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_nutrient_order_by!],
        "filter the rows returned"
        where: food_nutrient_bool_exp
    ): [food_nutrient!]!
    "fetch aggregated fields from the table: \"food_nutrient\""
    food_nutrient_aggregate(
        "distinct select on columns"
        distinct_on: [food_nutrient_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_nutrient_order_by!],
        "filter the rows returned"
        where: food_nutrient_bool_exp
    ): food_nutrient_aggregate!
    "fetch data from the table: \"food_nutrient\" using primary key columns"
    food_nutrient_by_pk(id: Int!): food_nutrient
    "fetch data from the table: \"food_portion\""
    food_portion(
        "distinct select on columns"
        distinct_on: [food_portion_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_portion_order_by!],
        "filter the rows returned"
        where: food_portion_bool_exp
    ): [food_portion!]!
    "fetch aggregated fields from the table: \"food_portion\""
    food_portion_aggregate(
        "distinct select on columns"
        distinct_on: [food_portion_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_portion_order_by!],
        "filter the rows returned"
        where: food_portion_bool_exp
    ): food_portion_aggregate!
    "fetch data from the table: \"food_portion\" using primary key columns"
    food_portion_by_pk(id: Int!): food_portion
    "fetch data from the table: \"measure_unit\""
    measure_unit(
        "distinct select on columns"
        distinct_on: [measure_unit_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [measure_unit_order_by!],
        "filter the rows returned"
        where: measure_unit_bool_exp
    ): [measure_unit!]!
    "fetch aggregated fields from the table: \"measure_unit\""
    measure_unit_aggregate(
        "distinct select on columns"
        distinct_on: [measure_unit_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [measure_unit_order_by!],
        "filter the rows returned"
        where: measure_unit_bool_exp
    ): measure_unit_aggregate!
    "fetch data from the table: \"measure_unit\" using primary key columns"
    measure_unit_by_pk(id: Int!): measure_unit
    "fetch data from the table: \"nutrient\""
    nutrient(
        "distinct select on columns"
        distinct_on: [nutrient_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [nutrient_order_by!],
        "filter the rows returned"
        where: nutrient_bool_exp
    ): [nutrient!]!
    "fetch aggregated fields from the table: \"nutrient\""
    nutrient_aggregate(
        "distinct select on columns"
        distinct_on: [nutrient_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [nutrient_order_by!],
        "filter the rows returned"
        where: nutrient_bool_exp
    ): nutrient_aggregate!
    "fetch data from the table: \"nutrient\" using primary key columns"
    nutrient_by_pk(id: Int!): nutrient
    "An array relationship"
    recipe_direction_durations(
        "distinct select on columns"
        distinct_on: [recipe_direction_durations_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_direction_durations_order_by!],
        "filter the rows returned"
        where: recipe_direction_durations_bool_exp
    ): [recipe_direction_durations!]!
    "An aggregate relationship"
    recipe_direction_durations_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_direction_durations_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_direction_durations_order_by!],
        "filter the rows returned"
        where: recipe_direction_durations_bool_exp
    ): recipe_direction_durations_aggregate!
    "fetch data from the table: \"recipe_direction_durations\" using primary key columns"
    recipe_direction_durations_by_pk(id: Int!): recipe_direction_durations
    "An array relationship"
    recipe_directions(
        "distinct select on columns"
        distinct_on: [recipe_directions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_directions_order_by!],
        "filter the rows returned"
        where: recipe_directions_bool_exp
    ): [recipe_directions!]!
    "An aggregate relationship"
    recipe_directions_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_directions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_directions_order_by!],
        "filter the rows returned"
        where: recipe_directions_bool_exp
    ): recipe_directions_aggregate!
    "fetch data from the table: \"recipe_directions\" using primary key columns"
    recipe_directions_by_pk(id: Int!): recipe_directions
    "fetch data from the table: \"recipe_ingredient_food_candidate\""
    recipe_ingredient_food_candidate(
        "distinct select on columns"
        distinct_on: [recipe_ingredient_food_candidate_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredient_food_candidate_order_by!],
        "filter the rows returned"
        where: recipe_ingredient_food_candidate_bool_exp
    ): [recipe_ingredient_food_candidate!]!
    "fetch aggregated fields from the table: \"recipe_ingredient_food_candidate\""
    recipe_ingredient_food_candidate_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_ingredient_food_candidate_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredient_food_candidate_order_by!],
        "filter the rows returned"
        where: recipe_ingredient_food_candidate_bool_exp
    ): recipe_ingredient_food_candidate_aggregate!
    "fetch data from the table: \"recipe_ingredient_food_candidate\" using primary key columns"
    recipe_ingredient_food_candidate_by_pk(id: Int!): recipe_ingredient_food_candidate
    "fetch data from the table: \"recipe_ingredient_groups\""
    recipe_ingredient_groups(
        "distinct select on columns"
        distinct_on: [recipe_ingredient_groups_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredient_groups_order_by!],
        "filter the rows returned"
        where: recipe_ingredient_groups_bool_exp
    ): [recipe_ingredient_groups!]!
    "An aggregate relationship"
    recipe_ingredient_groups_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_ingredient_groups_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredient_groups_order_by!],
        "filter the rows returned"
        where: recipe_ingredient_groups_bool_exp
    ): recipe_ingredient_groups_aggregate!
    "fetch data from the table: \"recipe_ingredient_groups\" using primary key columns"
    recipe_ingredient_groups_by_pk(id: Int!): recipe_ingredient_groups
    "fetch data from the table: \"recipe_ingredients\""
    recipe_ingredients(
        "distinct select on columns"
        distinct_on: [recipe_ingredients_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredients_order_by!],
        "filter the rows returned"
        where: recipe_ingredients_bool_exp
    ): [recipe_ingredients!]!
    "fetch aggregated fields from the table: \"recipe_ingredients\""
    recipe_ingredients_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_ingredients_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredients_order_by!],
        "filter the rows returned"
        where: recipe_ingredients_bool_exp
    ): recipe_ingredients_aggregate!
    "fetch data from the table: \"recipe_ingredients\" using primary key columns"
    recipe_ingredients_by_pk(id: Int!): recipe_ingredients
    "An array relationship"
    recipe_queues(
        "distinct select on columns"
        distinct_on: [recipe_queues_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_queues_order_by!],
        "filter the rows returned"
        where: recipe_queues_bool_exp
    ): [recipe_queues!]!
    "An aggregate relationship"
    recipe_queues_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_queues_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_queues_order_by!],
        "filter the rows returned"
        where: recipe_queues_bool_exp
    ): recipe_queues_aggregate!
    "fetch data from the table: \"recipe_queues\" using primary key columns"
    recipe_queues_by_pk(id: Int!): recipe_queues
    "fetch data from the table: \"recipe_tags\""
    recipe_tags(
        "distinct select on columns"
        distinct_on: [recipe_tags_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_tags_order_by!],
        "filter the rows returned"
        where: recipe_tags_bool_exp
    ): [recipe_tags!]!
    "fetch aggregated fields from the table: \"recipe_tags\""
    recipe_tags_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_tags_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_tags_order_by!],
        "filter the rows returned"
        where: recipe_tags_bool_exp
    ): recipe_tags_aggregate!
    "fetch data from the table: \"recipe_tags\" using primary key columns"
    recipe_tags_by_pk(id: Int!): recipe_tags
    "fetch data from the table: \"recipes\""
    recipes(
        "distinct select on columns"
        distinct_on: [recipes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipes_order_by!],
        "filter the rows returned"
        where: recipes_bool_exp
    ): [recipes!]!
    "fetch aggregated fields from the table: \"recipes\""
    recipes_aggregate(
        "distinct select on columns"
        distinct_on: [recipes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipes_order_by!],
        "filter the rows returned"
        where: recipes_bool_exp
    ): recipes_aggregate!
    "fetch data from the table: \"recipes\" using primary key columns"
    recipes_by_pk(id: Int!): recipes
    "execute function \"search_foods\" which returns \"food\""
    search_foods(
        "input parameters for function \"search_foods\""
        args: search_foods_args!,
        "distinct select on columns"
        distinct_on: [food_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_order_by!],
        "filter the rows returned"
        where: food_bool_exp
    ): [food!]!
    "execute function \"search_foods\" and query aggregates on result of table type \"food\""
    search_foods_aggregate(
        "input parameters for function \"search_foods\""
        args: search_foods_args!,
        "distinct select on columns"
        distinct_on: [food_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_order_by!],
        "filter the rows returned"
        where: food_bool_exp
    ): food_aggregate!
}

"columns and relationships of \"recipe_direction_durations\""
type recipe_direction_durations {
    duration: Int!
    id: Int!
    recipe_id: Int!
    seq_num: Int!
    type: String!
    unit_of_time: String!
}

"aggregated selection of \"recipe_direction_durations\""
type recipe_direction_durations_aggregate {
    aggregate: recipe_direction_durations_aggregate_fields
    nodes: [recipe_direction_durations!]!
}

"aggregate fields of \"recipe_direction_durations\""
type recipe_direction_durations_aggregate_fields {
    avg: recipe_direction_durations_avg_fields
    count(columns: [recipe_direction_durations_select_column!], distinct: Boolean): Int!
    max: recipe_direction_durations_max_fields
    min: recipe_direction_durations_min_fields
    stddev: recipe_direction_durations_stddev_fields
    stddev_pop: recipe_direction_durations_stddev_pop_fields
    stddev_samp: recipe_direction_durations_stddev_samp_fields
    sum: recipe_direction_durations_sum_fields
    var_pop: recipe_direction_durations_var_pop_fields
    var_samp: recipe_direction_durations_var_samp_fields
    variance: recipe_direction_durations_variance_fields
}

"aggregate avg on columns"
type recipe_direction_durations_avg_fields {
    duration: Float
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate max on columns"
type recipe_direction_durations_max_fields {
    duration: Int
    id: Int
    recipe_id: Int
    seq_num: Int
    type: String
    unit_of_time: String
}

"aggregate min on columns"
type recipe_direction_durations_min_fields {
    duration: Int
    id: Int
    recipe_id: Int
    seq_num: Int
    type: String
    unit_of_time: String
}

"response of any mutation on the table \"recipe_direction_durations\""
type recipe_direction_durations_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [recipe_direction_durations!]!
}

"aggregate stddev on columns"
type recipe_direction_durations_stddev_fields {
    duration: Float
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate stddev_pop on columns"
type recipe_direction_durations_stddev_pop_fields {
    duration: Float
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate stddev_samp on columns"
type recipe_direction_durations_stddev_samp_fields {
    duration: Float
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate sum on columns"
type recipe_direction_durations_sum_fields {
    duration: Int
    id: Int
    recipe_id: Int
    seq_num: Int
}

"aggregate var_pop on columns"
type recipe_direction_durations_var_pop_fields {
    duration: Float
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate var_samp on columns"
type recipe_direction_durations_var_samp_fields {
    duration: Float
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate variance on columns"
type recipe_direction_durations_variance_fields {
    duration: Float
    id: Float
    recipe_id: Float
    seq_num: Float
}

"columns and relationships of \"recipe_directions\""
type recipe_directions {
    id: Int!
    recipe_id: Int!
    seq_num: Int!
    step: String!
}

"aggregated selection of \"recipe_directions\""
type recipe_directions_aggregate {
    aggregate: recipe_directions_aggregate_fields
    nodes: [recipe_directions!]!
}

"aggregate fields of \"recipe_directions\""
type recipe_directions_aggregate_fields {
    avg: recipe_directions_avg_fields
    count(columns: [recipe_directions_select_column!], distinct: Boolean): Int!
    max: recipe_directions_max_fields
    min: recipe_directions_min_fields
    stddev: recipe_directions_stddev_fields
    stddev_pop: recipe_directions_stddev_pop_fields
    stddev_samp: recipe_directions_stddev_samp_fields
    sum: recipe_directions_sum_fields
    var_pop: recipe_directions_var_pop_fields
    var_samp: recipe_directions_var_samp_fields
    variance: recipe_directions_variance_fields
}

"aggregate avg on columns"
type recipe_directions_avg_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate max on columns"
type recipe_directions_max_fields {
    id: Int
    recipe_id: Int
    seq_num: Int
    step: String
}

"aggregate min on columns"
type recipe_directions_min_fields {
    id: Int
    recipe_id: Int
    seq_num: Int
    step: String
}

"response of any mutation on the table \"recipe_directions\""
type recipe_directions_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [recipe_directions!]!
}

"aggregate stddev on columns"
type recipe_directions_stddev_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate stddev_pop on columns"
type recipe_directions_stddev_pop_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate stddev_samp on columns"
type recipe_directions_stddev_samp_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate sum on columns"
type recipe_directions_sum_fields {
    id: Int
    recipe_id: Int
    seq_num: Int
}

"aggregate var_pop on columns"
type recipe_directions_var_pop_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate var_samp on columns"
type recipe_directions_var_samp_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate variance on columns"
type recipe_directions_variance_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"columns and relationships of \"recipe_ingredient_food_candidate\""
type recipe_ingredient_food_candidate {
    food_candidate_id: Int!
    id: Int!
    recipe_ingredient_id: Int!
}

"aggregated selection of \"recipe_ingredient_food_candidate\""
type recipe_ingredient_food_candidate_aggregate {
    aggregate: recipe_ingredient_food_candidate_aggregate_fields
    nodes: [recipe_ingredient_food_candidate!]!
}

"aggregate fields of \"recipe_ingredient_food_candidate\""
type recipe_ingredient_food_candidate_aggregate_fields {
    avg: recipe_ingredient_food_candidate_avg_fields
    count(columns: [recipe_ingredient_food_candidate_select_column!], distinct: Boolean): Int!
    max: recipe_ingredient_food_candidate_max_fields
    min: recipe_ingredient_food_candidate_min_fields
    stddev: recipe_ingredient_food_candidate_stddev_fields
    stddev_pop: recipe_ingredient_food_candidate_stddev_pop_fields
    stddev_samp: recipe_ingredient_food_candidate_stddev_samp_fields
    sum: recipe_ingredient_food_candidate_sum_fields
    var_pop: recipe_ingredient_food_candidate_var_pop_fields
    var_samp: recipe_ingredient_food_candidate_var_samp_fields
    variance: recipe_ingredient_food_candidate_variance_fields
}

"aggregate avg on columns"
type recipe_ingredient_food_candidate_avg_fields {
    food_candidate_id: Float
    id: Float
    recipe_ingredient_id: Float
}

"aggregate max on columns"
type recipe_ingredient_food_candidate_max_fields {
    food_candidate_id: Int
    id: Int
    recipe_ingredient_id: Int
}

"aggregate min on columns"
type recipe_ingredient_food_candidate_min_fields {
    food_candidate_id: Int
    id: Int
    recipe_ingredient_id: Int
}

"response of any mutation on the table \"recipe_ingredient_food_candidate\""
type recipe_ingredient_food_candidate_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [recipe_ingredient_food_candidate!]!
}

"aggregate stddev on columns"
type recipe_ingredient_food_candidate_stddev_fields {
    food_candidate_id: Float
    id: Float
    recipe_ingredient_id: Float
}

"aggregate stddev_pop on columns"
type recipe_ingredient_food_candidate_stddev_pop_fields {
    food_candidate_id: Float
    id: Float
    recipe_ingredient_id: Float
}

"aggregate stddev_samp on columns"
type recipe_ingredient_food_candidate_stddev_samp_fields {
    food_candidate_id: Float
    id: Float
    recipe_ingredient_id: Float
}

"aggregate sum on columns"
type recipe_ingredient_food_candidate_sum_fields {
    food_candidate_id: Int
    id: Int
    recipe_ingredient_id: Int
}

"aggregate var_pop on columns"
type recipe_ingredient_food_candidate_var_pop_fields {
    food_candidate_id: Float
    id: Float
    recipe_ingredient_id: Float
}

"aggregate var_samp on columns"
type recipe_ingredient_food_candidate_var_samp_fields {
    food_candidate_id: Float
    id: Float
    recipe_ingredient_id: Float
}

"aggregate variance on columns"
type recipe_ingredient_food_candidate_variance_fields {
    food_candidate_id: Float
    id: Float
    recipe_ingredient_id: Float
}

"columns and relationships of \"recipe_ingredient_groups\""
type recipe_ingredient_groups {
    "An array relationship"
    group_ingredients(
        "distinct select on columns"
        distinct_on: [recipe_ingredients_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredients_order_by!],
        "filter the rows returned"
        where: recipe_ingredients_bool_exp
    ): [recipe_ingredients!]!
    "An aggregate relationship"
    group_ingredients_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_ingredients_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredients_order_by!],
        "filter the rows returned"
        where: recipe_ingredients_bool_exp
    ): recipe_ingredients_aggregate!
    id: Int!
    name: String
    "An object relationship"
    recipe: recipes
    recipe_id: Int
    seq_num: Int
}

"aggregated selection of \"recipe_ingredient_groups\""
type recipe_ingredient_groups_aggregate {
    aggregate: recipe_ingredient_groups_aggregate_fields
    nodes: [recipe_ingredient_groups!]!
}

"aggregate fields of \"recipe_ingredient_groups\""
type recipe_ingredient_groups_aggregate_fields {
    avg: recipe_ingredient_groups_avg_fields
    count(columns: [recipe_ingredient_groups_select_column!], distinct: Boolean): Int!
    max: recipe_ingredient_groups_max_fields
    min: recipe_ingredient_groups_min_fields
    stddev: recipe_ingredient_groups_stddev_fields
    stddev_pop: recipe_ingredient_groups_stddev_pop_fields
    stddev_samp: recipe_ingredient_groups_stddev_samp_fields
    sum: recipe_ingredient_groups_sum_fields
    var_pop: recipe_ingredient_groups_var_pop_fields
    var_samp: recipe_ingredient_groups_var_samp_fields
    variance: recipe_ingredient_groups_variance_fields
}

"aggregate avg on columns"
type recipe_ingredient_groups_avg_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate max on columns"
type recipe_ingredient_groups_max_fields {
    id: Int
    name: String
    recipe_id: Int
    seq_num: Int
}

"aggregate min on columns"
type recipe_ingredient_groups_min_fields {
    id: Int
    name: String
    recipe_id: Int
    seq_num: Int
}

"response of any mutation on the table \"recipe_ingredient_groups\""
type recipe_ingredient_groups_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [recipe_ingredient_groups!]!
}

"aggregate stddev on columns"
type recipe_ingredient_groups_stddev_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate stddev_pop on columns"
type recipe_ingredient_groups_stddev_pop_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate stddev_samp on columns"
type recipe_ingredient_groups_stddev_samp_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate sum on columns"
type recipe_ingredient_groups_sum_fields {
    id: Int
    recipe_id: Int
    seq_num: Int
}

"aggregate var_pop on columns"
type recipe_ingredient_groups_var_pop_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate var_samp on columns"
type recipe_ingredient_groups_var_samp_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate variance on columns"
type recipe_ingredient_groups_variance_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"columns and relationships of \"recipe_ingredients\""
type recipe_ingredients {
    amount: Float
    comment: String
    "An object relationship"
    food: food
    "A computed field, executes function \"food_candidates_for_ingredient\""
    food_candidates(
        "distinct select on columns"
        distinct_on: [food_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_order_by!],
        "filter the rows returned"
        where: food_bool_exp
    ): [food!]
    food_id: Int
    group_id: Int
    id: Int!
    name: String
    "An array relationship"
    recipe_ingredient_food_candidates(
        "distinct select on columns"
        distinct_on: [recipe_ingredient_food_candidate_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredient_food_candidate_order_by!],
        "filter the rows returned"
        where: recipe_ingredient_food_candidate_bool_exp
    ): [recipe_ingredient_food_candidate!]!
    "An aggregate relationship"
    recipe_ingredient_food_candidates_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_ingredient_food_candidate_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredient_food_candidate_order_by!],
        "filter the rows returned"
        where: recipe_ingredient_food_candidate_bool_exp
    ): recipe_ingredient_food_candidate_aggregate!
    "An object relationship"
    recipe_ingredient_group: recipe_ingredient_groups
    seq_num: Int
    text: String!
    units: String
}

"aggregated selection of \"recipe_ingredients\""
type recipe_ingredients_aggregate {
    aggregate: recipe_ingredients_aggregate_fields
    nodes: [recipe_ingredients!]!
}

"aggregate fields of \"recipe_ingredients\""
type recipe_ingredients_aggregate_fields {
    avg: recipe_ingredients_avg_fields
    count(columns: [recipe_ingredients_select_column!], distinct: Boolean): Int!
    max: recipe_ingredients_max_fields
    min: recipe_ingredients_min_fields
    stddev: recipe_ingredients_stddev_fields
    stddev_pop: recipe_ingredients_stddev_pop_fields
    stddev_samp: recipe_ingredients_stddev_samp_fields
    sum: recipe_ingredients_sum_fields
    var_pop: recipe_ingredients_var_pop_fields
    var_samp: recipe_ingredients_var_samp_fields
    variance: recipe_ingredients_variance_fields
}

"aggregate avg on columns"
type recipe_ingredients_avg_fields {
    amount: Float
    food_id: Float
    group_id: Float
    id: Float
    seq_num: Float
}

"aggregate max on columns"
type recipe_ingredients_max_fields {
    amount: Float
    comment: String
    food_id: Int
    group_id: Int
    id: Int
    name: String
    seq_num: Int
    text: String
    units: String
}

"aggregate min on columns"
type recipe_ingredients_min_fields {
    amount: Float
    comment: String
    food_id: Int
    group_id: Int
    id: Int
    name: String
    seq_num: Int
    text: String
    units: String
}

"response of any mutation on the table \"recipe_ingredients\""
type recipe_ingredients_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [recipe_ingredients!]!
}

"aggregate stddev on columns"
type recipe_ingredients_stddev_fields {
    amount: Float
    food_id: Float
    group_id: Float
    id: Float
    seq_num: Float
}

"aggregate stddev_pop on columns"
type recipe_ingredients_stddev_pop_fields {
    amount: Float
    food_id: Float
    group_id: Float
    id: Float
    seq_num: Float
}

"aggregate stddev_samp on columns"
type recipe_ingredients_stddev_samp_fields {
    amount: Float
    food_id: Float
    group_id: Float
    id: Float
    seq_num: Float
}

"aggregate sum on columns"
type recipe_ingredients_sum_fields {
    amount: Float
    food_id: Int
    group_id: Int
    id: Int
    seq_num: Int
}

"aggregate var_pop on columns"
type recipe_ingredients_var_pop_fields {
    amount: Float
    food_id: Float
    group_id: Float
    id: Float
    seq_num: Float
}

"aggregate var_samp on columns"
type recipe_ingredients_var_samp_fields {
    amount: Float
    food_id: Float
    group_id: Float
    id: Float
    seq_num: Float
}

"aggregate variance on columns"
type recipe_ingredients_variance_fields {
    amount: Float
    food_id: Float
    group_id: Float
    id: Float
    seq_num: Float
}

"columns and relationships of \"recipe_queues\""
type recipe_queues {
    id: Int!
    queue_id: Int!
    recipe_id: Int!
    seq_num: Int
}

"aggregated selection of \"recipe_queues\""
type recipe_queues_aggregate {
    aggregate: recipe_queues_aggregate_fields
    nodes: [recipe_queues!]!
}

"aggregate fields of \"recipe_queues\""
type recipe_queues_aggregate_fields {
    avg: recipe_queues_avg_fields
    count(columns: [recipe_queues_select_column!], distinct: Boolean): Int!
    max: recipe_queues_max_fields
    min: recipe_queues_min_fields
    stddev: recipe_queues_stddev_fields
    stddev_pop: recipe_queues_stddev_pop_fields
    stddev_samp: recipe_queues_stddev_samp_fields
    sum: recipe_queues_sum_fields
    var_pop: recipe_queues_var_pop_fields
    var_samp: recipe_queues_var_samp_fields
    variance: recipe_queues_variance_fields
}

"aggregate avg on columns"
type recipe_queues_avg_fields {
    id: Float
    queue_id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate max on columns"
type recipe_queues_max_fields {
    id: Int
    queue_id: Int
    recipe_id: Int
    seq_num: Int
}

"aggregate min on columns"
type recipe_queues_min_fields {
    id: Int
    queue_id: Int
    recipe_id: Int
    seq_num: Int
}

"response of any mutation on the table \"recipe_queues\""
type recipe_queues_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [recipe_queues!]!
}

"aggregate stddev on columns"
type recipe_queues_stddev_fields {
    id: Float
    queue_id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate stddev_pop on columns"
type recipe_queues_stddev_pop_fields {
    id: Float
    queue_id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate stddev_samp on columns"
type recipe_queues_stddev_samp_fields {
    id: Float
    queue_id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate sum on columns"
type recipe_queues_sum_fields {
    id: Int
    queue_id: Int
    recipe_id: Int
    seq_num: Int
}

"aggregate var_pop on columns"
type recipe_queues_var_pop_fields {
    id: Float
    queue_id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate var_samp on columns"
type recipe_queues_var_samp_fields {
    id: Float
    queue_id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate variance on columns"
type recipe_queues_variance_fields {
    id: Float
    queue_id: Float
    recipe_id: Float
    seq_num: Float
}

"columns and relationships of \"recipe_tags\""
type recipe_tags {
    id: Int!
    name: String!
    recipe_id: Int!
    seq_num: Int
}

"aggregated selection of \"recipe_tags\""
type recipe_tags_aggregate {
    aggregate: recipe_tags_aggregate_fields
    nodes: [recipe_tags!]!
}

"aggregate fields of \"recipe_tags\""
type recipe_tags_aggregate_fields {
    avg: recipe_tags_avg_fields
    count(columns: [recipe_tags_select_column!], distinct: Boolean): Int!
    max: recipe_tags_max_fields
    min: recipe_tags_min_fields
    stddev: recipe_tags_stddev_fields
    stddev_pop: recipe_tags_stddev_pop_fields
    stddev_samp: recipe_tags_stddev_samp_fields
    sum: recipe_tags_sum_fields
    var_pop: recipe_tags_var_pop_fields
    var_samp: recipe_tags_var_samp_fields
    variance: recipe_tags_variance_fields
}

"aggregate avg on columns"
type recipe_tags_avg_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate max on columns"
type recipe_tags_max_fields {
    id: Int
    name: String
    recipe_id: Int
    seq_num: Int
}

"aggregate min on columns"
type recipe_tags_min_fields {
    id: Int
    name: String
    recipe_id: Int
    seq_num: Int
}

"response of any mutation on the table \"recipe_tags\""
type recipe_tags_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [recipe_tags!]!
}

"aggregate stddev on columns"
type recipe_tags_stddev_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate stddev_pop on columns"
type recipe_tags_stddev_pop_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate stddev_samp on columns"
type recipe_tags_stddev_samp_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate sum on columns"
type recipe_tags_sum_fields {
    id: Int
    recipe_id: Int
    seq_num: Int
}

"aggregate var_pop on columns"
type recipe_tags_var_pop_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate var_samp on columns"
type recipe_tags_var_samp_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"aggregate variance on columns"
type recipe_tags_variance_fields {
    id: Float
    recipe_id: Float
    seq_num: Float
}

"columns and relationships of \"recipes\""
type recipes {
    created_at: timestamptz!
    extraction_metadata(
        "JSON select path"
        path: String
    ): jsonb
    id: Int!
    image: String
    name: String!
    "An array relationship"
    recipe_direction_durations(
        "distinct select on columns"
        distinct_on: [recipe_direction_durations_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_direction_durations_order_by!],
        "filter the rows returned"
        where: recipe_direction_durations_bool_exp
    ): [recipe_direction_durations!]!
    "An aggregate relationship"
    recipe_direction_durations_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_direction_durations_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_direction_durations_order_by!],
        "filter the rows returned"
        where: recipe_direction_durations_bool_exp
    ): recipe_direction_durations_aggregate!
    "An array relationship"
    recipe_directions(
        "distinct select on columns"
        distinct_on: [recipe_directions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_directions_order_by!],
        "filter the rows returned"
        where: recipe_directions_bool_exp
    ): [recipe_directions!]!
    "An aggregate relationship"
    recipe_directions_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_directions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_directions_order_by!],
        "filter the rows returned"
        where: recipe_directions_bool_exp
    ): recipe_directions_aggregate!
    "fetch data from the table: \"recipe_ingredient_groups\""
    recipe_ingredient_groups(
        "distinct select on columns"
        distinct_on: [recipe_ingredient_groups_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredient_groups_order_by!],
        "filter the rows returned"
        where: recipe_ingredient_groups_bool_exp
    ): [recipe_ingredient_groups!]!
    "An aggregate relationship"
    recipe_ingredient_groups_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_ingredient_groups_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredient_groups_order_by!],
        "filter the rows returned"
        where: recipe_ingredient_groups_bool_exp
    ): recipe_ingredient_groups_aggregate!
    "An array relationship"
    recipe_queues(
        "distinct select on columns"
        distinct_on: [recipe_queues_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_queues_order_by!],
        "filter the rows returned"
        where: recipe_queues_bool_exp
    ): [recipe_queues!]!
    "An aggregate relationship"
    recipe_queues_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_queues_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_queues_order_by!],
        "filter the rows returned"
        where: recipe_queues_bool_exp
    ): recipe_queues_aggregate!
    "fetch data from the table: \"recipe_tags\""
    recipe_tags(
        "distinct select on columns"
        distinct_on: [recipe_tags_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_tags_order_by!],
        "filter the rows returned"
        where: recipe_tags_bool_exp
    ): [recipe_tags!]!
    "fetch aggregated fields from the table: \"recipe_tags\""
    recipe_tags_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_tags_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_tags_order_by!],
        "filter the rows returned"
        where: recipe_tags_bool_exp
    ): recipe_tags_aggregate!
    source: String!
    updated_at: timestamptz!
}

"aggregated selection of \"recipes\""
type recipes_aggregate {
    aggregate: recipes_aggregate_fields
    nodes: [recipes!]!
}

"aggregate fields of \"recipes\""
type recipes_aggregate_fields {
    avg: recipes_avg_fields
    count(columns: [recipes_select_column!], distinct: Boolean): Int!
    max: recipes_max_fields
    min: recipes_min_fields
    stddev: recipes_stddev_fields
    stddev_pop: recipes_stddev_pop_fields
    stddev_samp: recipes_stddev_samp_fields
    sum: recipes_sum_fields
    var_pop: recipes_var_pop_fields
    var_samp: recipes_var_samp_fields
    variance: recipes_variance_fields
}

"aggregate avg on columns"
type recipes_avg_fields {
    id: Float
}

"aggregate max on columns"
type recipes_max_fields {
    created_at: timestamptz
    id: Int
    image: String
    name: String
    source: String
    updated_at: timestamptz
}

"aggregate min on columns"
type recipes_min_fields {
    created_at: timestamptz
    id: Int
    image: String
    name: String
    source: String
    updated_at: timestamptz
}

"response of any mutation on the table \"recipes\""
type recipes_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [recipes!]!
}

"aggregate stddev on columns"
type recipes_stddev_fields {
    id: Float
}

"aggregate stddev_pop on columns"
type recipes_stddev_pop_fields {
    id: Float
}

"aggregate stddev_samp on columns"
type recipes_stddev_samp_fields {
    id: Float
}

"aggregate sum on columns"
type recipes_sum_fields {
    id: Int
}

"aggregate var_pop on columns"
type recipes_var_pop_fields {
    id: Float
}

"aggregate var_samp on columns"
type recipes_var_samp_fields {
    id: Float
}

"aggregate variance on columns"
type recipes_variance_fields {
    id: Float
}

type subscription_root {
    "fetch data from the table: \"food\""
    food(
        "distinct select on columns"
        distinct_on: [food_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_order_by!],
        "filter the rows returned"
        where: food_bool_exp
    ): [food!]!
    "fetch aggregated fields from the table: \"food\""
    food_aggregate(
        "distinct select on columns"
        distinct_on: [food_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_order_by!],
        "filter the rows returned"
        where: food_bool_exp
    ): food_aggregate!
    "fetch data from the table: \"food_attribute\""
    food_attribute(
        "distinct select on columns"
        distinct_on: [food_attribute_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_attribute_order_by!],
        "filter the rows returned"
        where: food_attribute_bool_exp
    ): [food_attribute!]!
    "fetch aggregated fields from the table: \"food_attribute\""
    food_attribute_aggregate(
        "distinct select on columns"
        distinct_on: [food_attribute_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_attribute_order_by!],
        "filter the rows returned"
        where: food_attribute_bool_exp
    ): food_attribute_aggregate!
    "fetch data from the table: \"food_attribute\" using primary key columns"
    food_attribute_by_pk(id: Int!): food_attribute
    "fetch data from the table: \"food_attribute_type\""
    food_attribute_type(
        "distinct select on columns"
        distinct_on: [food_attribute_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_attribute_type_order_by!],
        "filter the rows returned"
        where: food_attribute_type_bool_exp
    ): [food_attribute_type!]!
    "fetch aggregated fields from the table: \"food_attribute_type\""
    food_attribute_type_aggregate(
        "distinct select on columns"
        distinct_on: [food_attribute_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_attribute_type_order_by!],
        "filter the rows returned"
        where: food_attribute_type_bool_exp
    ): food_attribute_type_aggregate!
    "fetch data from the table: \"food_attribute_type\" using primary key columns"
    food_attribute_type_by_pk(id: Int!): food_attribute_type
    "fetch data from the table: \"food\" using primary key columns"
    food_by_pk(fdc_id: Int!): food
    "fetch data from the table: \"food_category\""
    food_category(
        "distinct select on columns"
        distinct_on: [food_category_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_category_order_by!],
        "filter the rows returned"
        where: food_category_bool_exp
    ): [food_category!]!
    "fetch aggregated fields from the table: \"food_category\""
    food_category_aggregate(
        "distinct select on columns"
        distinct_on: [food_category_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_category_order_by!],
        "filter the rows returned"
        where: food_category_bool_exp
    ): food_category_aggregate!
    "fetch data from the table: \"food_category\" using primary key columns"
    food_category_by_pk(id: Int!): food_category
    "fetch data from the table: \"food_nutrient\""
    food_nutrient(
        "distinct select on columns"
        distinct_on: [food_nutrient_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_nutrient_order_by!],
        "filter the rows returned"
        where: food_nutrient_bool_exp
    ): [food_nutrient!]!
    "fetch aggregated fields from the table: \"food_nutrient\""
    food_nutrient_aggregate(
        "distinct select on columns"
        distinct_on: [food_nutrient_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_nutrient_order_by!],
        "filter the rows returned"
        where: food_nutrient_bool_exp
    ): food_nutrient_aggregate!
    "fetch data from the table: \"food_nutrient\" using primary key columns"
    food_nutrient_by_pk(id: Int!): food_nutrient
    "fetch data from the table: \"food_portion\""
    food_portion(
        "distinct select on columns"
        distinct_on: [food_portion_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_portion_order_by!],
        "filter the rows returned"
        where: food_portion_bool_exp
    ): [food_portion!]!
    "fetch aggregated fields from the table: \"food_portion\""
    food_portion_aggregate(
        "distinct select on columns"
        distinct_on: [food_portion_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_portion_order_by!],
        "filter the rows returned"
        where: food_portion_bool_exp
    ): food_portion_aggregate!
    "fetch data from the table: \"food_portion\" using primary key columns"
    food_portion_by_pk(id: Int!): food_portion
    "fetch data from the table: \"measure_unit\""
    measure_unit(
        "distinct select on columns"
        distinct_on: [measure_unit_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [measure_unit_order_by!],
        "filter the rows returned"
        where: measure_unit_bool_exp
    ): [measure_unit!]!
    "fetch aggregated fields from the table: \"measure_unit\""
    measure_unit_aggregate(
        "distinct select on columns"
        distinct_on: [measure_unit_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [measure_unit_order_by!],
        "filter the rows returned"
        where: measure_unit_bool_exp
    ): measure_unit_aggregate!
    "fetch data from the table: \"measure_unit\" using primary key columns"
    measure_unit_by_pk(id: Int!): measure_unit
    "fetch data from the table: \"nutrient\""
    nutrient(
        "distinct select on columns"
        distinct_on: [nutrient_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [nutrient_order_by!],
        "filter the rows returned"
        where: nutrient_bool_exp
    ): [nutrient!]!
    "fetch aggregated fields from the table: \"nutrient\""
    nutrient_aggregate(
        "distinct select on columns"
        distinct_on: [nutrient_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [nutrient_order_by!],
        "filter the rows returned"
        where: nutrient_bool_exp
    ): nutrient_aggregate!
    "fetch data from the table: \"nutrient\" using primary key columns"
    nutrient_by_pk(id: Int!): nutrient
    "An array relationship"
    recipe_direction_durations(
        "distinct select on columns"
        distinct_on: [recipe_direction_durations_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_direction_durations_order_by!],
        "filter the rows returned"
        where: recipe_direction_durations_bool_exp
    ): [recipe_direction_durations!]!
    "An aggregate relationship"
    recipe_direction_durations_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_direction_durations_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_direction_durations_order_by!],
        "filter the rows returned"
        where: recipe_direction_durations_bool_exp
    ): recipe_direction_durations_aggregate!
    "fetch data from the table: \"recipe_direction_durations\" using primary key columns"
    recipe_direction_durations_by_pk(id: Int!): recipe_direction_durations
    "An array relationship"
    recipe_directions(
        "distinct select on columns"
        distinct_on: [recipe_directions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_directions_order_by!],
        "filter the rows returned"
        where: recipe_directions_bool_exp
    ): [recipe_directions!]!
    "An aggregate relationship"
    recipe_directions_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_directions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_directions_order_by!],
        "filter the rows returned"
        where: recipe_directions_bool_exp
    ): recipe_directions_aggregate!
    "fetch data from the table: \"recipe_directions\" using primary key columns"
    recipe_directions_by_pk(id: Int!): recipe_directions
    "fetch data from the table: \"recipe_ingredient_food_candidate\""
    recipe_ingredient_food_candidate(
        "distinct select on columns"
        distinct_on: [recipe_ingredient_food_candidate_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredient_food_candidate_order_by!],
        "filter the rows returned"
        where: recipe_ingredient_food_candidate_bool_exp
    ): [recipe_ingredient_food_candidate!]!
    "fetch aggregated fields from the table: \"recipe_ingredient_food_candidate\""
    recipe_ingredient_food_candidate_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_ingredient_food_candidate_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredient_food_candidate_order_by!],
        "filter the rows returned"
        where: recipe_ingredient_food_candidate_bool_exp
    ): recipe_ingredient_food_candidate_aggregate!
    "fetch data from the table: \"recipe_ingredient_food_candidate\" using primary key columns"
    recipe_ingredient_food_candidate_by_pk(id: Int!): recipe_ingredient_food_candidate
    "fetch data from the table: \"recipe_ingredient_groups\""
    recipe_ingredient_groups(
        "distinct select on columns"
        distinct_on: [recipe_ingredient_groups_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredient_groups_order_by!],
        "filter the rows returned"
        where: recipe_ingredient_groups_bool_exp
    ): [recipe_ingredient_groups!]!
    "An aggregate relationship"
    recipe_ingredient_groups_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_ingredient_groups_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredient_groups_order_by!],
        "filter the rows returned"
        where: recipe_ingredient_groups_bool_exp
    ): recipe_ingredient_groups_aggregate!
    "fetch data from the table: \"recipe_ingredient_groups\" using primary key columns"
    recipe_ingredient_groups_by_pk(id: Int!): recipe_ingredient_groups
    "fetch data from the table: \"recipe_ingredients\""
    recipe_ingredients(
        "distinct select on columns"
        distinct_on: [recipe_ingredients_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredients_order_by!],
        "filter the rows returned"
        where: recipe_ingredients_bool_exp
    ): [recipe_ingredients!]!
    "fetch aggregated fields from the table: \"recipe_ingredients\""
    recipe_ingredients_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_ingredients_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_ingredients_order_by!],
        "filter the rows returned"
        where: recipe_ingredients_bool_exp
    ): recipe_ingredients_aggregate!
    "fetch data from the table: \"recipe_ingredients\" using primary key columns"
    recipe_ingredients_by_pk(id: Int!): recipe_ingredients
    "An array relationship"
    recipe_queues(
        "distinct select on columns"
        distinct_on: [recipe_queues_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_queues_order_by!],
        "filter the rows returned"
        where: recipe_queues_bool_exp
    ): [recipe_queues!]!
    "An aggregate relationship"
    recipe_queues_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_queues_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_queues_order_by!],
        "filter the rows returned"
        where: recipe_queues_bool_exp
    ): recipe_queues_aggregate!
    "fetch data from the table: \"recipe_queues\" using primary key columns"
    recipe_queues_by_pk(id: Int!): recipe_queues
    "fetch data from the table: \"recipe_tags\""
    recipe_tags(
        "distinct select on columns"
        distinct_on: [recipe_tags_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_tags_order_by!],
        "filter the rows returned"
        where: recipe_tags_bool_exp
    ): [recipe_tags!]!
    "fetch aggregated fields from the table: \"recipe_tags\""
    recipe_tags_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_tags_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_tags_order_by!],
        "filter the rows returned"
        where: recipe_tags_bool_exp
    ): recipe_tags_aggregate!
    "fetch data from the table: \"recipe_tags\" using primary key columns"
    recipe_tags_by_pk(id: Int!): recipe_tags
    "fetch data from the table: \"recipes\""
    recipes(
        "distinct select on columns"
        distinct_on: [recipes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipes_order_by!],
        "filter the rows returned"
        where: recipes_bool_exp
    ): [recipes!]!
    "fetch aggregated fields from the table: \"recipes\""
    recipes_aggregate(
        "distinct select on columns"
        distinct_on: [recipes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipes_order_by!],
        "filter the rows returned"
        where: recipes_bool_exp
    ): recipes_aggregate!
    "fetch data from the table: \"recipes\" using primary key columns"
    recipes_by_pk(id: Int!): recipes
    "execute function \"search_foods\" which returns \"food\""
    search_foods(
        "input parameters for function \"search_foods\""
        args: search_foods_args!,
        "distinct select on columns"
        distinct_on: [food_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_order_by!],
        "filter the rows returned"
        where: food_bool_exp
    ): [food!]!
    "execute function \"search_foods\" and query aggregates on result of table type \"food\""
    search_foods_aggregate(
        "input parameters for function \"search_foods\""
        args: search_foods_args!,
        "distinct select on columns"
        distinct_on: [food_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_order_by!],
        "filter the rows returned"
        where: food_bool_exp
    ): food_aggregate!
}

"unique or primary key constraints on table \"food_attribute\""
enum food_attribute_constraint {
    "unique or primary key constraint"
    food_attribute_pkey
}

"select columns of table \"food_attribute\""
enum food_attribute_select_column {
    "column name"
    fdc_id
    "column name"
    food_attribute_type_id
    "column name"
    id
    "column name"
    name
    "column name"
    seq_num
    "column name"
    value
}

"unique or primary key constraints on table \"food_attribute_type\""
enum food_attribute_type_constraint {
    "unique or primary key constraint"
    food_attribute_type_pkey
}

"select columns of table \"food_attribute_type\""
enum food_attribute_type_select_column {
    "column name"
    description
    "column name"
    id
    "column name"
    name
}

"update columns of table \"food_attribute_type\""
enum food_attribute_type_update_column {
    "column name"
    description
    "column name"
    id
    "column name"
    name
}

"update columns of table \"food_attribute\""
enum food_attribute_update_column {
    "column name"
    fdc_id
    "column name"
    food_attribute_type_id
    "column name"
    id
    "column name"
    name
    "column name"
    seq_num
    "column name"
    value
}

"unique or primary key constraints on table \"food_category\""
enum food_category_constraint {
    "unique or primary key constraint"
    food_category_pkey
}

"select columns of table \"food_category\""
enum food_category_select_column {
    "column name"
    code
    "column name"
    description
    "column name"
    id
}

"update columns of table \"food_category\""
enum food_category_update_column {
    "column name"
    code
    "column name"
    description
    "column name"
    id
}

"unique or primary key constraints on table \"food\""
enum food_constraint {
    "unique or primary key constraint"
    food_pkey
}

"unique or primary key constraints on table \"food_nutrient\""
enum food_nutrient_constraint {
    "unique or primary key constraint"
    food_nutrient_pkey
}

"select columns of table \"food_nutrient\""
enum food_nutrient_select_column {
    "column name"
    amount
    "column name"
    data_points
    "column name"
    derivation_id
    "column name"
    fdc_id
    "column name"
    footnote
    "column name"
    id
    "column name"
    max
    "column name"
    median
    "column name"
    min
    "column name"
    min_year_acquired
    "column name"
    nutrient_id
}

"update columns of table \"food_nutrient\""
enum food_nutrient_update_column {
    "column name"
    amount
    "column name"
    data_points
    "column name"
    derivation_id
    "column name"
    fdc_id
    "column name"
    footnote
    "column name"
    id
    "column name"
    max
    "column name"
    median
    "column name"
    min
    "column name"
    min_year_acquired
    "column name"
    nutrient_id
}

"unique or primary key constraints on table \"food_portion\""
enum food_portion_constraint {
    "unique or primary key constraint"
    food_portion_pkey
}

"select columns of table \"food_portion\""
enum food_portion_select_column {
    "column name"
    amount
    "column name"
    data_points
    "column name"
    fdc_id
    "column name"
    footnote
    "column name"
    gram_weight
    "column name"
    id
    "column name"
    measure_unit_id
    "column name"
    min_year_acquired
    "column name"
    modifier
    "column name"
    portion_description
    "column name"
    seq_num
}

"update columns of table \"food_portion\""
enum food_portion_update_column {
    "column name"
    amount
    "column name"
    data_points
    "column name"
    fdc_id
    "column name"
    footnote
    "column name"
    gram_weight
    "column name"
    id
    "column name"
    measure_unit_id
    "column name"
    min_year_acquired
    "column name"
    modifier
    "column name"
    portion_description
    "column name"
    seq_num
}

"select columns of table \"food\""
enum food_select_column {
    "column name"
    data_type
    "column name"
    description
    "column name"
    description_tsv
    "column name"
    fdc_id
    "column name"
    food_category_id
    "column name"
    publication_date
}

"update columns of table \"food\""
enum food_update_column {
    "column name"
    data_type
    "column name"
    description
    "column name"
    description_tsv
    "column name"
    fdc_id
    "column name"
    food_category_id
    "column name"
    publication_date
}

"unique or primary key constraints on table \"measure_unit\""
enum measure_unit_constraint {
    "unique or primary key constraint"
    measure_unit_pkey
}

"select columns of table \"measure_unit\""
enum measure_unit_select_column {
    "column name"
    id
    "column name"
    ml
    "column name"
    name
}

"update columns of table \"measure_unit\""
enum measure_unit_update_column {
    "column name"
    id
    "column name"
    ml
    "column name"
    name
}

"unique or primary key constraints on table \"nutrient\""
enum nutrient_constraint {
    "unique or primary key constraint"
    nutrient_pkey
}

"select columns of table \"nutrient\""
enum nutrient_select_column {
    "column name"
    id
    "column name"
    name
    "column name"
    nutrient_nbr
    "column name"
    rank
    "column name"
    unit_name
}

"update columns of table \"nutrient\""
enum nutrient_update_column {
    "column name"
    id
    "column name"
    name
    "column name"
    nutrient_nbr
    "column name"
    rank
    "column name"
    unit_name
}

"column ordering options"
enum order_by {
    "in ascending order, nulls last"
    asc
    "in ascending order, nulls first"
    asc_nulls_first
    "in ascending order, nulls last"
    asc_nulls_last
    "in descending order, nulls first"
    desc
    "in descending order, nulls first"
    desc_nulls_first
    "in descending order, nulls last"
    desc_nulls_last
}

"unique or primary key constraints on table \"recipe_direction_durations\""
enum recipe_direction_durations_constraint {
    "unique or primary key constraint"
    recipe_direction_durations_pkey
}

"select columns of table \"recipe_direction_durations\""
enum recipe_direction_durations_select_column {
    "column name"
    duration
    "column name"
    id
    "column name"
    recipe_id
    "column name"
    seq_num
    "column name"
    type
    "column name"
    unit_of_time
}

"update columns of table \"recipe_direction_durations\""
enum recipe_direction_durations_update_column {
    "column name"
    duration
    "column name"
    id
    "column name"
    recipe_id
    "column name"
    seq_num
    "column name"
    type
    "column name"
    unit_of_time
}

"unique or primary key constraints on table \"recipe_directions\""
enum recipe_directions_constraint {
    "unique or primary key constraint"
    recipe_directions_pkey
    "unique or primary key constraint"
    recipe_directions_recipe_id_seq_num_key
}

"select columns of table \"recipe_directions\""
enum recipe_directions_select_column {
    "column name"
    id
    "column name"
    recipe_id
    "column name"
    seq_num
    "column name"
    step
}

"update columns of table \"recipe_directions\""
enum recipe_directions_update_column {
    "column name"
    id
    "column name"
    recipe_id
    "column name"
    seq_num
    "column name"
    step
}

"unique or primary key constraints on table \"recipe_ingredient_food_candidate\""
enum recipe_ingredient_food_candidate_constraint {
    "unique or primary key constraint"
    recipe_ingredient_food_candidate_pkey
}

"select columns of table \"recipe_ingredient_food_candidate\""
enum recipe_ingredient_food_candidate_select_column {
    "column name"
    food_candidate_id
    "column name"
    id
    "column name"
    recipe_ingredient_id
}

"update columns of table \"recipe_ingredient_food_candidate\""
enum recipe_ingredient_food_candidate_update_column {
    "column name"
    food_candidate_id
    "column name"
    id
    "column name"
    recipe_ingredient_id
}

"unique or primary key constraints on table \"recipe_ingredient_groups\""
enum recipe_ingredient_groups_constraint {
    "unique or primary key constraint"
    recipe_ingredient_groups_pkey
    "unique or primary key constraint"
    recipe_ingredient_groups_recipe_id_seq_num_key
}

"select columns of table \"recipe_ingredient_groups\""
enum recipe_ingredient_groups_select_column {
    "column name"
    id
    "column name"
    name
    "column name"
    recipe_id
    "column name"
    seq_num
}

"update columns of table \"recipe_ingredient_groups\""
enum recipe_ingredient_groups_update_column {
    "column name"
    id
    "column name"
    name
    "column name"
    recipe_id
    "column name"
    seq_num
}

"unique or primary key constraints on table \"recipe_ingredients\""
enum recipe_ingredients_constraint {
    "unique or primary key constraint"
    recipe_ingredients_group_id_seq_num_key
    "unique or primary key constraint"
    recipe_ingredients_pkey
}

"select columns of table \"recipe_ingredients\""
enum recipe_ingredients_select_column {
    "column name"
    amount
    "column name"
    comment
    "column name"
    food_id
    "column name"
    group_id
    "column name"
    id
    "column name"
    name
    "column name"
    seq_num
    "column name"
    text
    "column name"
    units
}

"update columns of table \"recipe_ingredients\""
enum recipe_ingredients_update_column {
    "column name"
    amount
    "column name"
    comment
    "column name"
    food_id
    "column name"
    group_id
    "column name"
    id
    "column name"
    name
    "column name"
    seq_num
    "column name"
    text
    "column name"
    units
}

"unique or primary key constraints on table \"recipe_queues\""
enum recipe_queues_constraint {
    "unique or primary key constraint"
    recipe_queues_pkey
}

"select columns of table \"recipe_queues\""
enum recipe_queues_select_column {
    "column name"
    id
    "column name"
    queue_id
    "column name"
    recipe_id
    "column name"
    seq_num
}

"update columns of table \"recipe_queues\""
enum recipe_queues_update_column {
    "column name"
    id
    "column name"
    queue_id
    "column name"
    recipe_id
    "column name"
    seq_num
}

"unique or primary key constraints on table \"recipe_tags\""
enum recipe_tags_constraint {
    "unique or primary key constraint"
    recipe_tags_pkey
    "unique or primary key constraint"
    recipe_tags_recipe_id_name_key
}

"select columns of table \"recipe_tags\""
enum recipe_tags_select_column {
    "column name"
    id
    "column name"
    name
    "column name"
    recipe_id
    "column name"
    seq_num
}

"update columns of table \"recipe_tags\""
enum recipe_tags_update_column {
    "column name"
    id
    "column name"
    name
    "column name"
    recipe_id
    "column name"
    seq_num
}

"unique or primary key constraints on table \"recipes\""
enum recipes_constraint {
    "unique or primary key constraint"
    recipes_pkey
    "unique or primary key constraint"
    recipes_source_key
}

"select columns of table \"recipes\""
enum recipes_select_column {
    "column name"
    created_at
    "column name"
    extraction_metadata
    "column name"
    id
    "column name"
    image
    "column name"
    name
    "column name"
    source
    "column name"
    updated_at
}

"update columns of table \"recipes\""
enum recipes_update_column {
    "column name"
    created_at
    "column name"
    extraction_metadata
    "column name"
    id
    "column name"
    image
    "column name"
    name
    "column name"
    source
    "column name"
    updated_at
}

"Boolean expression to compare columns of type \"Float\". All fields are combined with logical 'AND'."
input Float_comparison_exp {
    _eq: Float
    _gt: Float
    _gte: Float
    _in: [Float!]
    _is_null: Boolean
    _lt: Float
    _lte: Float
    _neq: Float
    _nin: [Float!]
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _is_null: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
}

"Boolean expression to compare columns of type \"float8\". All fields are combined with logical 'AND'."
input float8_comparison_exp {
    _eq: float8
    _gt: float8
    _gte: float8
    _in: [float8!]
    _is_null: Boolean
    _lt: float8
    _lte: float8
    _neq: float8
    _nin: [float8!]
}

"order by aggregate values of table \"food_attribute\""
input food_attribute_aggregate_order_by {
    avg: food_attribute_avg_order_by
    count: order_by
    max: food_attribute_max_order_by
    min: food_attribute_min_order_by
    stddev: food_attribute_stddev_order_by
    stddev_pop: food_attribute_stddev_pop_order_by
    stddev_samp: food_attribute_stddev_samp_order_by
    sum: food_attribute_sum_order_by
    var_pop: food_attribute_var_pop_order_by
    var_samp: food_attribute_var_samp_order_by
    variance: food_attribute_variance_order_by
}

"input type for inserting array relation for remote table \"food_attribute\""
input food_attribute_arr_rel_insert_input {
    data: [food_attribute_insert_input!]!
    "on conflict condition"
    on_conflict: food_attribute_on_conflict
}

"order by avg() on columns of table \"food_attribute\""
input food_attribute_avg_order_by {
    fdc_id: order_by
    food_attribute_type_id: order_by
    id: order_by
    seq_num: order_by
}

"Boolean expression to filter rows from the table \"food_attribute\". All fields are combined with a logical 'AND'."
input food_attribute_bool_exp {
    _and: [food_attribute_bool_exp!]
    _not: food_attribute_bool_exp
    _or: [food_attribute_bool_exp!]
    fdc_id: Int_comparison_exp
    food_attribute_type: food_attribute_type_bool_exp
    food_attribute_type_id: Int_comparison_exp
    id: Int_comparison_exp
    name: String_comparison_exp
    seq_num: Int_comparison_exp
    value: String_comparison_exp
}

"input type for incrementing numeric columns in table \"food_attribute\""
input food_attribute_inc_input {
    fdc_id: Int
    food_attribute_type_id: Int
    id: Int
    seq_num: Int
}

"input type for inserting data into table \"food_attribute\""
input food_attribute_insert_input {
    fdc_id: Int
    food_attribute_type: food_attribute_type_obj_rel_insert_input
    food_attribute_type_id: Int
    id: Int
    name: String
    seq_num: Int
    value: String
}

"order by max() on columns of table \"food_attribute\""
input food_attribute_max_order_by {
    fdc_id: order_by
    food_attribute_type_id: order_by
    id: order_by
    name: order_by
    seq_num: order_by
    value: order_by
}

"order by min() on columns of table \"food_attribute\""
input food_attribute_min_order_by {
    fdc_id: order_by
    food_attribute_type_id: order_by
    id: order_by
    name: order_by
    seq_num: order_by
    value: order_by
}

"on conflict condition type for table \"food_attribute\""
input food_attribute_on_conflict {
    constraint: food_attribute_constraint!
    update_columns: [food_attribute_update_column!]! = []
    where: food_attribute_bool_exp
}

"Ordering options when selecting data from \"food_attribute\"."
input food_attribute_order_by {
    fdc_id: order_by
    food_attribute_type: food_attribute_type_order_by
    food_attribute_type_id: order_by
    id: order_by
    name: order_by
    seq_num: order_by
    value: order_by
}

"primary key columns input for table: food_attribute"
input food_attribute_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"food_attribute\""
input food_attribute_set_input {
    fdc_id: Int
    food_attribute_type_id: Int
    id: Int
    name: String
    seq_num: Int
    value: String
}

"order by stddev() on columns of table \"food_attribute\""
input food_attribute_stddev_order_by {
    fdc_id: order_by
    food_attribute_type_id: order_by
    id: order_by
    seq_num: order_by
}

"order by stddev_pop() on columns of table \"food_attribute\""
input food_attribute_stddev_pop_order_by {
    fdc_id: order_by
    food_attribute_type_id: order_by
    id: order_by
    seq_num: order_by
}

"order by stddev_samp() on columns of table \"food_attribute\""
input food_attribute_stddev_samp_order_by {
    fdc_id: order_by
    food_attribute_type_id: order_by
    id: order_by
    seq_num: order_by
}

"order by sum() on columns of table \"food_attribute\""
input food_attribute_sum_order_by {
    fdc_id: order_by
    food_attribute_type_id: order_by
    id: order_by
    seq_num: order_by
}

"Boolean expression to filter rows from the table \"food_attribute_type\". All fields are combined with a logical 'AND'."
input food_attribute_type_bool_exp {
    _and: [food_attribute_type_bool_exp!]
    _not: food_attribute_type_bool_exp
    _or: [food_attribute_type_bool_exp!]
    description: String_comparison_exp
    id: Int_comparison_exp
    name: String_comparison_exp
}

"input type for incrementing numeric columns in table \"food_attribute_type\""
input food_attribute_type_inc_input {
    id: Int
}

"input type for inserting data into table \"food_attribute_type\""
input food_attribute_type_insert_input {
    description: String
    id: Int
    name: String
}

"input type for inserting object relation for remote table \"food_attribute_type\""
input food_attribute_type_obj_rel_insert_input {
    data: food_attribute_type_insert_input!
    "on conflict condition"
    on_conflict: food_attribute_type_on_conflict
}

"on conflict condition type for table \"food_attribute_type\""
input food_attribute_type_on_conflict {
    constraint: food_attribute_type_constraint!
    update_columns: [food_attribute_type_update_column!]! = []
    where: food_attribute_type_bool_exp
}

"Ordering options when selecting data from \"food_attribute_type\"."
input food_attribute_type_order_by {
    description: order_by
    id: order_by
    name: order_by
}

"primary key columns input for table: food_attribute_type"
input food_attribute_type_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"food_attribute_type\""
input food_attribute_type_set_input {
    description: String
    id: Int
    name: String
}

"order by var_pop() on columns of table \"food_attribute\""
input food_attribute_var_pop_order_by {
    fdc_id: order_by
    food_attribute_type_id: order_by
    id: order_by
    seq_num: order_by
}

"order by var_samp() on columns of table \"food_attribute\""
input food_attribute_var_samp_order_by {
    fdc_id: order_by
    food_attribute_type_id: order_by
    id: order_by
    seq_num: order_by
}

"order by variance() on columns of table \"food_attribute\""
input food_attribute_variance_order_by {
    fdc_id: order_by
    food_attribute_type_id: order_by
    id: order_by
    seq_num: order_by
}

"Boolean expression to filter rows from the table \"food\". All fields are combined with a logical 'AND'."
input food_bool_exp {
    _and: [food_bool_exp!]
    _not: food_bool_exp
    _or: [food_bool_exp!]
    data_type: food_data_type_enum_comparison_exp
    description: String_comparison_exp
    description_tsv: tsvector_comparison_exp
    fdc_id: Int_comparison_exp
    food_attributes: food_attribute_bool_exp
    food_category: food_category_bool_exp
    food_category_id: Int_comparison_exp
    food_nutrients: food_nutrient_bool_exp
    food_portions: food_portion_bool_exp
    publication_date: timestamp_comparison_exp
}

"Boolean expression to filter rows from the table \"food_category\". All fields are combined with a logical 'AND'."
input food_category_bool_exp {
    _and: [food_category_bool_exp!]
    _not: food_category_bool_exp
    _or: [food_category_bool_exp!]
    code: Int_comparison_exp
    description: String_comparison_exp
    id: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"food_category\""
input food_category_inc_input {
    code: Int
    id: Int
}

"input type for inserting data into table \"food_category\""
input food_category_insert_input {
    code: Int
    description: String
    id: Int
}

"input type for inserting object relation for remote table \"food_category\""
input food_category_obj_rel_insert_input {
    data: food_category_insert_input!
    "on conflict condition"
    on_conflict: food_category_on_conflict
}

"on conflict condition type for table \"food_category\""
input food_category_on_conflict {
    constraint: food_category_constraint!
    update_columns: [food_category_update_column!]! = []
    where: food_category_bool_exp
}

"Ordering options when selecting data from \"food_category\"."
input food_category_order_by {
    code: order_by
    description: order_by
    id: order_by
}

"primary key columns input for table: food_category"
input food_category_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"food_category\""
input food_category_set_input {
    code: Int
    description: String
    id: Int
}

"Boolean expression to compare columns of type \"food_data_type_enum\". All fields are combined with logical 'AND'."
input food_data_type_enum_comparison_exp {
    _eq: food_data_type_enum
    _gt: food_data_type_enum
    _gte: food_data_type_enum
    _in: [food_data_type_enum!]
    _is_null: Boolean
    _lt: food_data_type_enum
    _lte: food_data_type_enum
    _neq: food_data_type_enum
    _nin: [food_data_type_enum!]
}

"input type for incrementing numeric columns in table \"food\""
input food_inc_input {
    fdc_id: Int
    food_category_id: Int
}

"input type for inserting data into table \"food\""
input food_insert_input {
    data_type: food_data_type_enum
    description: String
    description_tsv: tsvector
    fdc_id: Int
    food_attributes: food_attribute_arr_rel_insert_input
    food_category: food_category_obj_rel_insert_input
    food_category_id: Int
    food_nutrients: food_nutrient_arr_rel_insert_input
    food_portions: food_portion_arr_rel_insert_input
    publication_date: timestamp
}

"order by aggregate values of table \"food_nutrient\""
input food_nutrient_aggregate_order_by {
    avg: food_nutrient_avg_order_by
    count: order_by
    max: food_nutrient_max_order_by
    min: food_nutrient_min_order_by
    stddev: food_nutrient_stddev_order_by
    stddev_pop: food_nutrient_stddev_pop_order_by
    stddev_samp: food_nutrient_stddev_samp_order_by
    sum: food_nutrient_sum_order_by
    var_pop: food_nutrient_var_pop_order_by
    var_samp: food_nutrient_var_samp_order_by
    variance: food_nutrient_variance_order_by
}

"input type for inserting array relation for remote table \"food_nutrient\""
input food_nutrient_arr_rel_insert_input {
    data: [food_nutrient_insert_input!]!
    "on conflict condition"
    on_conflict: food_nutrient_on_conflict
}

"order by avg() on columns of table \"food_nutrient\""
input food_nutrient_avg_order_by {
    amount: order_by
    data_points: order_by
    derivation_id: order_by
    fdc_id: order_by
    id: order_by
    max: order_by
    median: order_by
    min: order_by
    min_year_acquired: order_by
    nutrient_id: order_by
}

"Boolean expression to filter rows from the table \"food_nutrient\". All fields are combined with a logical 'AND'."
input food_nutrient_bool_exp {
    _and: [food_nutrient_bool_exp!]
    _not: food_nutrient_bool_exp
    _or: [food_nutrient_bool_exp!]
    amount: float8_comparison_exp
    data_points: Int_comparison_exp
    derivation_id: Int_comparison_exp
    fdc_id: Int_comparison_exp
    footnote: String_comparison_exp
    id: Int_comparison_exp
    max: float8_comparison_exp
    median: float8_comparison_exp
    min: float8_comparison_exp
    min_year_acquired: Int_comparison_exp
    nutrient: nutrient_bool_exp
    nutrient_id: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"food_nutrient\""
input food_nutrient_inc_input {
    amount: float8
    data_points: Int
    derivation_id: Int
    fdc_id: Int
    id: Int
    max: float8
    median: float8
    min: float8
    min_year_acquired: Int
    nutrient_id: Int
}

"input type for inserting data into table \"food_nutrient\""
input food_nutrient_insert_input {
    amount: float8
    data_points: Int
    derivation_id: Int
    fdc_id: Int
    footnote: String
    id: Int
    max: float8
    median: float8
    min: float8
    min_year_acquired: Int
    nutrient: nutrient_obj_rel_insert_input
    nutrient_id: Int
}

"order by max() on columns of table \"food_nutrient\""
input food_nutrient_max_order_by {
    amount: order_by
    data_points: order_by
    derivation_id: order_by
    fdc_id: order_by
    footnote: order_by
    id: order_by
    max: order_by
    median: order_by
    min: order_by
    min_year_acquired: order_by
    nutrient_id: order_by
}

"order by min() on columns of table \"food_nutrient\""
input food_nutrient_min_order_by {
    amount: order_by
    data_points: order_by
    derivation_id: order_by
    fdc_id: order_by
    footnote: order_by
    id: order_by
    max: order_by
    median: order_by
    min: order_by
    min_year_acquired: order_by
    nutrient_id: order_by
}

"on conflict condition type for table \"food_nutrient\""
input food_nutrient_on_conflict {
    constraint: food_nutrient_constraint!
    update_columns: [food_nutrient_update_column!]! = []
    where: food_nutrient_bool_exp
}

"Ordering options when selecting data from \"food_nutrient\"."
input food_nutrient_order_by {
    amount: order_by
    data_points: order_by
    derivation_id: order_by
    fdc_id: order_by
    footnote: order_by
    id: order_by
    max: order_by
    median: order_by
    min: order_by
    min_year_acquired: order_by
    nutrient: nutrient_order_by
    nutrient_id: order_by
}

"primary key columns input for table: food_nutrient"
input food_nutrient_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"food_nutrient\""
input food_nutrient_set_input {
    amount: float8
    data_points: Int
    derivation_id: Int
    fdc_id: Int
    footnote: String
    id: Int
    max: float8
    median: float8
    min: float8
    min_year_acquired: Int
    nutrient_id: Int
}

"order by stddev() on columns of table \"food_nutrient\""
input food_nutrient_stddev_order_by {
    amount: order_by
    data_points: order_by
    derivation_id: order_by
    fdc_id: order_by
    id: order_by
    max: order_by
    median: order_by
    min: order_by
    min_year_acquired: order_by
    nutrient_id: order_by
}

"order by stddev_pop() on columns of table \"food_nutrient\""
input food_nutrient_stddev_pop_order_by {
    amount: order_by
    data_points: order_by
    derivation_id: order_by
    fdc_id: order_by
    id: order_by
    max: order_by
    median: order_by
    min: order_by
    min_year_acquired: order_by
    nutrient_id: order_by
}

"order by stddev_samp() on columns of table \"food_nutrient\""
input food_nutrient_stddev_samp_order_by {
    amount: order_by
    data_points: order_by
    derivation_id: order_by
    fdc_id: order_by
    id: order_by
    max: order_by
    median: order_by
    min: order_by
    min_year_acquired: order_by
    nutrient_id: order_by
}

"order by sum() on columns of table \"food_nutrient\""
input food_nutrient_sum_order_by {
    amount: order_by
    data_points: order_by
    derivation_id: order_by
    fdc_id: order_by
    id: order_by
    max: order_by
    median: order_by
    min: order_by
    min_year_acquired: order_by
    nutrient_id: order_by
}

"order by var_pop() on columns of table \"food_nutrient\""
input food_nutrient_var_pop_order_by {
    amount: order_by
    data_points: order_by
    derivation_id: order_by
    fdc_id: order_by
    id: order_by
    max: order_by
    median: order_by
    min: order_by
    min_year_acquired: order_by
    nutrient_id: order_by
}

"order by var_samp() on columns of table \"food_nutrient\""
input food_nutrient_var_samp_order_by {
    amount: order_by
    data_points: order_by
    derivation_id: order_by
    fdc_id: order_by
    id: order_by
    max: order_by
    median: order_by
    min: order_by
    min_year_acquired: order_by
    nutrient_id: order_by
}

"order by variance() on columns of table \"food_nutrient\""
input food_nutrient_variance_order_by {
    amount: order_by
    data_points: order_by
    derivation_id: order_by
    fdc_id: order_by
    id: order_by
    max: order_by
    median: order_by
    min: order_by
    min_year_acquired: order_by
    nutrient_id: order_by
}

"input type for inserting object relation for remote table \"food\""
input food_obj_rel_insert_input {
    data: food_insert_input!
    "on conflict condition"
    on_conflict: food_on_conflict
}

"on conflict condition type for table \"food\""
input food_on_conflict {
    constraint: food_constraint!
    update_columns: [food_update_column!]! = []
    where: food_bool_exp
}

"Ordering options when selecting data from \"food\"."
input food_order_by {
    data_type: order_by
    description: order_by
    description_tsv: order_by
    fdc_id: order_by
    food_attributes_aggregate: food_attribute_aggregate_order_by
    food_category: food_category_order_by
    food_category_id: order_by
    food_nutrients_aggregate: food_nutrient_aggregate_order_by
    food_portions_aggregate: food_portion_aggregate_order_by
    publication_date: order_by
}

"primary key columns input for table: food"
input food_pk_columns_input {
    fdc_id: Int!
}

"order by aggregate values of table \"food_portion\""
input food_portion_aggregate_order_by {
    avg: food_portion_avg_order_by
    count: order_by
    max: food_portion_max_order_by
    min: food_portion_min_order_by
    stddev: food_portion_stddev_order_by
    stddev_pop: food_portion_stddev_pop_order_by
    stddev_samp: food_portion_stddev_samp_order_by
    sum: food_portion_sum_order_by
    var_pop: food_portion_var_pop_order_by
    var_samp: food_portion_var_samp_order_by
    variance: food_portion_variance_order_by
}

"input type for inserting array relation for remote table \"food_portion\""
input food_portion_arr_rel_insert_input {
    data: [food_portion_insert_input!]!
    "on conflict condition"
    on_conflict: food_portion_on_conflict
}

"order by avg() on columns of table \"food_portion\""
input food_portion_avg_order_by {
    amount: order_by
    data_points: order_by
    fdc_id: order_by
    gram_weight: order_by
    id: order_by
    measure_unit_id: order_by
    min_year_acquired: order_by
    seq_num: order_by
}

"Boolean expression to filter rows from the table \"food_portion\". All fields are combined with a logical 'AND'."
input food_portion_bool_exp {
    _and: [food_portion_bool_exp!]
    _not: food_portion_bool_exp
    _or: [food_portion_bool_exp!]
    amount: float8_comparison_exp
    data_points: Int_comparison_exp
    fdc_id: Int_comparison_exp
    footnote: String_comparison_exp
    gram_weight: float8_comparison_exp
    id: Int_comparison_exp
    measure_unit: measure_unit_bool_exp
    measure_unit_id: Int_comparison_exp
    min_year_acquired: Int_comparison_exp
    modifier: String_comparison_exp
    portion_description: String_comparison_exp
    seq_num: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"food_portion\""
input food_portion_inc_input {
    amount: float8
    data_points: Int
    fdc_id: Int
    gram_weight: float8
    id: Int
    measure_unit_id: Int
    min_year_acquired: Int
    seq_num: Int
}

"input type for inserting data into table \"food_portion\""
input food_portion_insert_input {
    amount: float8
    data_points: Int
    fdc_id: Int
    footnote: String
    gram_weight: float8
    id: Int
    measure_unit: measure_unit_obj_rel_insert_input
    measure_unit_id: Int
    min_year_acquired: Int
    modifier: String
    portion_description: String
    seq_num: Int
}

"order by max() on columns of table \"food_portion\""
input food_portion_max_order_by {
    amount: order_by
    data_points: order_by
    fdc_id: order_by
    footnote: order_by
    gram_weight: order_by
    id: order_by
    measure_unit_id: order_by
    min_year_acquired: order_by
    modifier: order_by
    portion_description: order_by
    seq_num: order_by
}

"order by min() on columns of table \"food_portion\""
input food_portion_min_order_by {
    amount: order_by
    data_points: order_by
    fdc_id: order_by
    footnote: order_by
    gram_weight: order_by
    id: order_by
    measure_unit_id: order_by
    min_year_acquired: order_by
    modifier: order_by
    portion_description: order_by
    seq_num: order_by
}

"on conflict condition type for table \"food_portion\""
input food_portion_on_conflict {
    constraint: food_portion_constraint!
    update_columns: [food_portion_update_column!]! = []
    where: food_portion_bool_exp
}

"Ordering options when selecting data from \"food_portion\"."
input food_portion_order_by {
    amount: order_by
    data_points: order_by
    fdc_id: order_by
    footnote: order_by
    gram_weight: order_by
    id: order_by
    measure_unit: measure_unit_order_by
    measure_unit_id: order_by
    min_year_acquired: order_by
    modifier: order_by
    portion_description: order_by
    seq_num: order_by
}

"primary key columns input for table: food_portion"
input food_portion_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"food_portion\""
input food_portion_set_input {
    amount: float8
    data_points: Int
    fdc_id: Int
    footnote: String
    gram_weight: float8
    id: Int
    measure_unit_id: Int
    min_year_acquired: Int
    modifier: String
    portion_description: String
    seq_num: Int
}

"order by stddev() on columns of table \"food_portion\""
input food_portion_stddev_order_by {
    amount: order_by
    data_points: order_by
    fdc_id: order_by
    gram_weight: order_by
    id: order_by
    measure_unit_id: order_by
    min_year_acquired: order_by
    seq_num: order_by
}

"order by stddev_pop() on columns of table \"food_portion\""
input food_portion_stddev_pop_order_by {
    amount: order_by
    data_points: order_by
    fdc_id: order_by
    gram_weight: order_by
    id: order_by
    measure_unit_id: order_by
    min_year_acquired: order_by
    seq_num: order_by
}

"order by stddev_samp() on columns of table \"food_portion\""
input food_portion_stddev_samp_order_by {
    amount: order_by
    data_points: order_by
    fdc_id: order_by
    gram_weight: order_by
    id: order_by
    measure_unit_id: order_by
    min_year_acquired: order_by
    seq_num: order_by
}

"order by sum() on columns of table \"food_portion\""
input food_portion_sum_order_by {
    amount: order_by
    data_points: order_by
    fdc_id: order_by
    gram_weight: order_by
    id: order_by
    measure_unit_id: order_by
    min_year_acquired: order_by
    seq_num: order_by
}

"order by var_pop() on columns of table \"food_portion\""
input food_portion_var_pop_order_by {
    amount: order_by
    data_points: order_by
    fdc_id: order_by
    gram_weight: order_by
    id: order_by
    measure_unit_id: order_by
    min_year_acquired: order_by
    seq_num: order_by
}

"order by var_samp() on columns of table \"food_portion\""
input food_portion_var_samp_order_by {
    amount: order_by
    data_points: order_by
    fdc_id: order_by
    gram_weight: order_by
    id: order_by
    measure_unit_id: order_by
    min_year_acquired: order_by
    seq_num: order_by
}

"order by variance() on columns of table \"food_portion\""
input food_portion_variance_order_by {
    amount: order_by
    data_points: order_by
    fdc_id: order_by
    gram_weight: order_by
    id: order_by
    measure_unit_id: order_by
    min_year_acquired: order_by
    seq_num: order_by
}

"input type for updating data in table \"food\""
input food_set_input {
    data_type: food_data_type_enum
    description: String
    description_tsv: tsvector
    fdc_id: Int
    food_category_id: Int
    publication_date: timestamp
}

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
    "is the column contained in the given json value"
    _contained_in: jsonb
    "does the column contain the given json value at the top level"
    _contains: jsonb
    _eq: jsonb
    _gt: jsonb
    _gte: jsonb
    "does the string exist as a top-level key in the column"
    _has_key: String
    "do all of these strings exist as top-level keys in the column"
    _has_keys_all: [String!]
    "do any of these strings exist as top-level keys in the column"
    _has_keys_any: [String!]
    _in: [jsonb!]
    _is_null: Boolean
    _lt: jsonb
    _lte: jsonb
    _neq: jsonb
    _nin: [jsonb!]
}

"Boolean expression to filter rows from the table \"measure_unit\". All fields are combined with a logical 'AND'."
input measure_unit_bool_exp {
    _and: [measure_unit_bool_exp!]
    _not: measure_unit_bool_exp
    _or: [measure_unit_bool_exp!]
    id: Int_comparison_exp
    ml: float8_comparison_exp
    name: String_comparison_exp
}

"input type for incrementing numeric columns in table \"measure_unit\""
input measure_unit_inc_input {
    id: Int
    ml: float8
}

"input type for inserting data into table \"measure_unit\""
input measure_unit_insert_input {
    id: Int
    ml: float8
    name: String
}

"input type for inserting object relation for remote table \"measure_unit\""
input measure_unit_obj_rel_insert_input {
    data: measure_unit_insert_input!
    "on conflict condition"
    on_conflict: measure_unit_on_conflict
}

"on conflict condition type for table \"measure_unit\""
input measure_unit_on_conflict {
    constraint: measure_unit_constraint!
    update_columns: [measure_unit_update_column!]! = []
    where: measure_unit_bool_exp
}

"Ordering options when selecting data from \"measure_unit\"."
input measure_unit_order_by {
    id: order_by
    ml: order_by
    name: order_by
}

"primary key columns input for table: measure_unit"
input measure_unit_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"measure_unit\""
input measure_unit_set_input {
    id: Int
    ml: float8
    name: String
}

"Boolean expression to filter rows from the table \"nutrient\". All fields are combined with a logical 'AND'."
input nutrient_bool_exp {
    _and: [nutrient_bool_exp!]
    _not: nutrient_bool_exp
    _or: [nutrient_bool_exp!]
    id: Int_comparison_exp
    name: String_comparison_exp
    nutrient_nbr: Int_comparison_exp
    rank: Int_comparison_exp
    unit_name: String_comparison_exp
}

"input type for incrementing numeric columns in table \"nutrient\""
input nutrient_inc_input {
    id: Int
    nutrient_nbr: Int
    rank: Int
}

"input type for inserting data into table \"nutrient\""
input nutrient_insert_input {
    id: Int
    name: String
    nutrient_nbr: Int
    rank: Int
    unit_name: String
}

"input type for inserting object relation for remote table \"nutrient\""
input nutrient_obj_rel_insert_input {
    data: nutrient_insert_input!
    "on conflict condition"
    on_conflict: nutrient_on_conflict
}

"on conflict condition type for table \"nutrient\""
input nutrient_on_conflict {
    constraint: nutrient_constraint!
    update_columns: [nutrient_update_column!]! = []
    where: nutrient_bool_exp
}

"Ordering options when selecting data from \"nutrient\"."
input nutrient_order_by {
    id: order_by
    name: order_by
    nutrient_nbr: order_by
    rank: order_by
    unit_name: order_by
}

"primary key columns input for table: nutrient"
input nutrient_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"nutrient\""
input nutrient_set_input {
    id: Int
    name: String
    nutrient_nbr: Int
    rank: Int
    unit_name: String
}

"order by aggregate values of table \"recipe_direction_durations\""
input recipe_direction_durations_aggregate_order_by {
    avg: recipe_direction_durations_avg_order_by
    count: order_by
    max: recipe_direction_durations_max_order_by
    min: recipe_direction_durations_min_order_by
    stddev: recipe_direction_durations_stddev_order_by
    stddev_pop: recipe_direction_durations_stddev_pop_order_by
    stddev_samp: recipe_direction_durations_stddev_samp_order_by
    sum: recipe_direction_durations_sum_order_by
    var_pop: recipe_direction_durations_var_pop_order_by
    var_samp: recipe_direction_durations_var_samp_order_by
    variance: recipe_direction_durations_variance_order_by
}

"input type for inserting array relation for remote table \"recipe_direction_durations\""
input recipe_direction_durations_arr_rel_insert_input {
    data: [recipe_direction_durations_insert_input!]!
    "on conflict condition"
    on_conflict: recipe_direction_durations_on_conflict
}

"order by avg() on columns of table \"recipe_direction_durations\""
input recipe_direction_durations_avg_order_by {
    duration: order_by
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"Boolean expression to filter rows from the table \"recipe_direction_durations\". All fields are combined with a logical 'AND'."
input recipe_direction_durations_bool_exp {
    _and: [recipe_direction_durations_bool_exp!]
    _not: recipe_direction_durations_bool_exp
    _or: [recipe_direction_durations_bool_exp!]
    duration: Int_comparison_exp
    id: Int_comparison_exp
    recipe_id: Int_comparison_exp
    seq_num: Int_comparison_exp
    type: String_comparison_exp
    unit_of_time: String_comparison_exp
}

"input type for incrementing numeric columns in table \"recipe_direction_durations\""
input recipe_direction_durations_inc_input {
    duration: Int
    id: Int
    recipe_id: Int
    seq_num: Int
}

"input type for inserting data into table \"recipe_direction_durations\""
input recipe_direction_durations_insert_input {
    duration: Int
    id: Int
    recipe_id: Int
    seq_num: Int
    type: String
    unit_of_time: String
}

"order by max() on columns of table \"recipe_direction_durations\""
input recipe_direction_durations_max_order_by {
    duration: order_by
    id: order_by
    recipe_id: order_by
    seq_num: order_by
    type: order_by
    unit_of_time: order_by
}

"order by min() on columns of table \"recipe_direction_durations\""
input recipe_direction_durations_min_order_by {
    duration: order_by
    id: order_by
    recipe_id: order_by
    seq_num: order_by
    type: order_by
    unit_of_time: order_by
}

"on conflict condition type for table \"recipe_direction_durations\""
input recipe_direction_durations_on_conflict {
    constraint: recipe_direction_durations_constraint!
    update_columns: [recipe_direction_durations_update_column!]! = []
    where: recipe_direction_durations_bool_exp
}

"Ordering options when selecting data from \"recipe_direction_durations\"."
input recipe_direction_durations_order_by {
    duration: order_by
    id: order_by
    recipe_id: order_by
    seq_num: order_by
    type: order_by
    unit_of_time: order_by
}

"primary key columns input for table: recipe_direction_durations"
input recipe_direction_durations_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"recipe_direction_durations\""
input recipe_direction_durations_set_input {
    duration: Int
    id: Int
    recipe_id: Int
    seq_num: Int
    type: String
    unit_of_time: String
}

"order by stddev() on columns of table \"recipe_direction_durations\""
input recipe_direction_durations_stddev_order_by {
    duration: order_by
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by stddev_pop() on columns of table \"recipe_direction_durations\""
input recipe_direction_durations_stddev_pop_order_by {
    duration: order_by
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by stddev_samp() on columns of table \"recipe_direction_durations\""
input recipe_direction_durations_stddev_samp_order_by {
    duration: order_by
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by sum() on columns of table \"recipe_direction_durations\""
input recipe_direction_durations_sum_order_by {
    duration: order_by
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by var_pop() on columns of table \"recipe_direction_durations\""
input recipe_direction_durations_var_pop_order_by {
    duration: order_by
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by var_samp() on columns of table \"recipe_direction_durations\""
input recipe_direction_durations_var_samp_order_by {
    duration: order_by
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by variance() on columns of table \"recipe_direction_durations\""
input recipe_direction_durations_variance_order_by {
    duration: order_by
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by aggregate values of table \"recipe_directions\""
input recipe_directions_aggregate_order_by {
    avg: recipe_directions_avg_order_by
    count: order_by
    max: recipe_directions_max_order_by
    min: recipe_directions_min_order_by
    stddev: recipe_directions_stddev_order_by
    stddev_pop: recipe_directions_stddev_pop_order_by
    stddev_samp: recipe_directions_stddev_samp_order_by
    sum: recipe_directions_sum_order_by
    var_pop: recipe_directions_var_pop_order_by
    var_samp: recipe_directions_var_samp_order_by
    variance: recipe_directions_variance_order_by
}

"input type for inserting array relation for remote table \"recipe_directions\""
input recipe_directions_arr_rel_insert_input {
    data: [recipe_directions_insert_input!]!
    "on conflict condition"
    on_conflict: recipe_directions_on_conflict
}

"order by avg() on columns of table \"recipe_directions\""
input recipe_directions_avg_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"Boolean expression to filter rows from the table \"recipe_directions\". All fields are combined with a logical 'AND'."
input recipe_directions_bool_exp {
    _and: [recipe_directions_bool_exp!]
    _not: recipe_directions_bool_exp
    _or: [recipe_directions_bool_exp!]
    id: Int_comparison_exp
    recipe_id: Int_comparison_exp
    seq_num: Int_comparison_exp
    step: String_comparison_exp
}

"input type for incrementing numeric columns in table \"recipe_directions\""
input recipe_directions_inc_input {
    id: Int
    recipe_id: Int
    seq_num: Int
}

"input type for inserting data into table \"recipe_directions\""
input recipe_directions_insert_input {
    id: Int
    recipe_id: Int
    seq_num: Int
    step: String
}

"order by max() on columns of table \"recipe_directions\""
input recipe_directions_max_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
    step: order_by
}

"order by min() on columns of table \"recipe_directions\""
input recipe_directions_min_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
    step: order_by
}

"on conflict condition type for table \"recipe_directions\""
input recipe_directions_on_conflict {
    constraint: recipe_directions_constraint!
    update_columns: [recipe_directions_update_column!]! = []
    where: recipe_directions_bool_exp
}

"Ordering options when selecting data from \"recipe_directions\"."
input recipe_directions_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
    step: order_by
}

"primary key columns input for table: recipe_directions"
input recipe_directions_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"recipe_directions\""
input recipe_directions_set_input {
    id: Int
    recipe_id: Int
    seq_num: Int
    step: String
}

"order by stddev() on columns of table \"recipe_directions\""
input recipe_directions_stddev_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by stddev_pop() on columns of table \"recipe_directions\""
input recipe_directions_stddev_pop_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by stddev_samp() on columns of table \"recipe_directions\""
input recipe_directions_stddev_samp_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by sum() on columns of table \"recipe_directions\""
input recipe_directions_sum_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by var_pop() on columns of table \"recipe_directions\""
input recipe_directions_var_pop_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by var_samp() on columns of table \"recipe_directions\""
input recipe_directions_var_samp_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by variance() on columns of table \"recipe_directions\""
input recipe_directions_variance_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by aggregate values of table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_aggregate_order_by {
    avg: recipe_ingredient_food_candidate_avg_order_by
    count: order_by
    max: recipe_ingredient_food_candidate_max_order_by
    min: recipe_ingredient_food_candidate_min_order_by
    stddev: recipe_ingredient_food_candidate_stddev_order_by
    stddev_pop: recipe_ingredient_food_candidate_stddev_pop_order_by
    stddev_samp: recipe_ingredient_food_candidate_stddev_samp_order_by
    sum: recipe_ingredient_food_candidate_sum_order_by
    var_pop: recipe_ingredient_food_candidate_var_pop_order_by
    var_samp: recipe_ingredient_food_candidate_var_samp_order_by
    variance: recipe_ingredient_food_candidate_variance_order_by
}

"input type for inserting array relation for remote table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_arr_rel_insert_input {
    data: [recipe_ingredient_food_candidate_insert_input!]!
    "on conflict condition"
    on_conflict: recipe_ingredient_food_candidate_on_conflict
}

"order by avg() on columns of table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_avg_order_by {
    food_candidate_id: order_by
    id: order_by
    recipe_ingredient_id: order_by
}

"Boolean expression to filter rows from the table \"recipe_ingredient_food_candidate\". All fields are combined with a logical 'AND'."
input recipe_ingredient_food_candidate_bool_exp {
    _and: [recipe_ingredient_food_candidate_bool_exp!]
    _not: recipe_ingredient_food_candidate_bool_exp
    _or: [recipe_ingredient_food_candidate_bool_exp!]
    food_candidate_id: Int_comparison_exp
    id: Int_comparison_exp
    recipe_ingredient_id: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_inc_input {
    food_candidate_id: Int
    id: Int
    recipe_ingredient_id: Int
}

"input type for inserting data into table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_insert_input {
    food_candidate_id: Int
    id: Int
    recipe_ingredient_id: Int
}

"order by max() on columns of table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_max_order_by {
    food_candidate_id: order_by
    id: order_by
    recipe_ingredient_id: order_by
}

"order by min() on columns of table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_min_order_by {
    food_candidate_id: order_by
    id: order_by
    recipe_ingredient_id: order_by
}

"on conflict condition type for table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_on_conflict {
    constraint: recipe_ingredient_food_candidate_constraint!
    update_columns: [recipe_ingredient_food_candidate_update_column!]! = []
    where: recipe_ingredient_food_candidate_bool_exp
}

"Ordering options when selecting data from \"recipe_ingredient_food_candidate\"."
input recipe_ingredient_food_candidate_order_by {
    food_candidate_id: order_by
    id: order_by
    recipe_ingredient_id: order_by
}

"primary key columns input for table: recipe_ingredient_food_candidate"
input recipe_ingredient_food_candidate_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_set_input {
    food_candidate_id: Int
    id: Int
    recipe_ingredient_id: Int
}

"order by stddev() on columns of table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_stddev_order_by {
    food_candidate_id: order_by
    id: order_by
    recipe_ingredient_id: order_by
}

"order by stddev_pop() on columns of table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_stddev_pop_order_by {
    food_candidate_id: order_by
    id: order_by
    recipe_ingredient_id: order_by
}

"order by stddev_samp() on columns of table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_stddev_samp_order_by {
    food_candidate_id: order_by
    id: order_by
    recipe_ingredient_id: order_by
}

"order by sum() on columns of table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_sum_order_by {
    food_candidate_id: order_by
    id: order_by
    recipe_ingredient_id: order_by
}

"order by var_pop() on columns of table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_var_pop_order_by {
    food_candidate_id: order_by
    id: order_by
    recipe_ingredient_id: order_by
}

"order by var_samp() on columns of table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_var_samp_order_by {
    food_candidate_id: order_by
    id: order_by
    recipe_ingredient_id: order_by
}

"order by variance() on columns of table \"recipe_ingredient_food_candidate\""
input recipe_ingredient_food_candidate_variance_order_by {
    food_candidate_id: order_by
    id: order_by
    recipe_ingredient_id: order_by
}

"order by aggregate values of table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_aggregate_order_by {
    avg: recipe_ingredient_groups_avg_order_by
    count: order_by
    max: recipe_ingredient_groups_max_order_by
    min: recipe_ingredient_groups_min_order_by
    stddev: recipe_ingredient_groups_stddev_order_by
    stddev_pop: recipe_ingredient_groups_stddev_pop_order_by
    stddev_samp: recipe_ingredient_groups_stddev_samp_order_by
    sum: recipe_ingredient_groups_sum_order_by
    var_pop: recipe_ingredient_groups_var_pop_order_by
    var_samp: recipe_ingredient_groups_var_samp_order_by
    variance: recipe_ingredient_groups_variance_order_by
}

"input type for inserting array relation for remote table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_arr_rel_insert_input {
    data: [recipe_ingredient_groups_insert_input!]!
    "on conflict condition"
    on_conflict: recipe_ingredient_groups_on_conflict
}

"order by avg() on columns of table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_avg_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"Boolean expression to filter rows from the table \"recipe_ingredient_groups\". All fields are combined with a logical 'AND'."
input recipe_ingredient_groups_bool_exp {
    _and: [recipe_ingredient_groups_bool_exp!]
    _not: recipe_ingredient_groups_bool_exp
    _or: [recipe_ingredient_groups_bool_exp!]
    group_ingredients: recipe_ingredients_bool_exp
    id: Int_comparison_exp
    name: String_comparison_exp
    recipe: recipes_bool_exp
    recipe_id: Int_comparison_exp
    seq_num: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_inc_input {
    id: Int
    recipe_id: Int
    seq_num: Int
}

"input type for inserting data into table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_insert_input {
    group_ingredients: recipe_ingredients_arr_rel_insert_input
    id: Int
    name: String
    recipe: recipes_obj_rel_insert_input
    recipe_id: Int
    seq_num: Int
}

"order by max() on columns of table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_max_order_by {
    id: order_by
    name: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by min() on columns of table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_min_order_by {
    id: order_by
    name: order_by
    recipe_id: order_by
    seq_num: order_by
}

"input type for inserting object relation for remote table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_obj_rel_insert_input {
    data: recipe_ingredient_groups_insert_input!
    "on conflict condition"
    on_conflict: recipe_ingredient_groups_on_conflict
}

"on conflict condition type for table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_on_conflict {
    constraint: recipe_ingredient_groups_constraint!
    update_columns: [recipe_ingredient_groups_update_column!]! = []
    where: recipe_ingredient_groups_bool_exp
}

"Ordering options when selecting data from \"recipe_ingredient_groups\"."
input recipe_ingredient_groups_order_by {
    group_ingredients_aggregate: recipe_ingredients_aggregate_order_by
    id: order_by
    name: order_by
    recipe: recipes_order_by
    recipe_id: order_by
    seq_num: order_by
}

"primary key columns input for table: recipe_ingredient_groups"
input recipe_ingredient_groups_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_set_input {
    id: Int
    name: String
    recipe_id: Int
    seq_num: Int
}

"order by stddev() on columns of table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_stddev_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by stddev_pop() on columns of table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_stddev_pop_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by stddev_samp() on columns of table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_stddev_samp_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by sum() on columns of table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_sum_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by var_pop() on columns of table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_var_pop_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by var_samp() on columns of table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_var_samp_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by variance() on columns of table \"recipe_ingredient_groups\""
input recipe_ingredient_groups_variance_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by aggregate values of table \"recipe_ingredients\""
input recipe_ingredients_aggregate_order_by {
    avg: recipe_ingredients_avg_order_by
    count: order_by
    max: recipe_ingredients_max_order_by
    min: recipe_ingredients_min_order_by
    stddev: recipe_ingredients_stddev_order_by
    stddev_pop: recipe_ingredients_stddev_pop_order_by
    stddev_samp: recipe_ingredients_stddev_samp_order_by
    sum: recipe_ingredients_sum_order_by
    var_pop: recipe_ingredients_var_pop_order_by
    var_samp: recipe_ingredients_var_samp_order_by
    variance: recipe_ingredients_variance_order_by
}

"input type for inserting array relation for remote table \"recipe_ingredients\""
input recipe_ingredients_arr_rel_insert_input {
    data: [recipe_ingredients_insert_input!]!
    "on conflict condition"
    on_conflict: recipe_ingredients_on_conflict
}

"order by avg() on columns of table \"recipe_ingredients\""
input recipe_ingredients_avg_order_by {
    amount: order_by
    food_id: order_by
    group_id: order_by
    id: order_by
    seq_num: order_by
}

"Boolean expression to filter rows from the table \"recipe_ingredients\". All fields are combined with a logical 'AND'."
input recipe_ingredients_bool_exp {
    _and: [recipe_ingredients_bool_exp!]
    _not: recipe_ingredients_bool_exp
    _or: [recipe_ingredients_bool_exp!]
    amount: Float_comparison_exp
    comment: String_comparison_exp
    food: food_bool_exp
    food_candidates: food_bool_exp
    food_id: Int_comparison_exp
    group_id: Int_comparison_exp
    id: Int_comparison_exp
    name: String_comparison_exp
    recipe_ingredient_food_candidates: recipe_ingredient_food_candidate_bool_exp
    recipe_ingredient_group: recipe_ingredient_groups_bool_exp
    seq_num: Int_comparison_exp
    text: String_comparison_exp
    units: String_comparison_exp
}

"input type for incrementing numeric columns in table \"recipe_ingredients\""
input recipe_ingredients_inc_input {
    amount: Float
    food_id: Int
    group_id: Int
    id: Int
    seq_num: Int
}

"input type for inserting data into table \"recipe_ingredients\""
input recipe_ingredients_insert_input {
    amount: Float
    comment: String
    food: food_obj_rel_insert_input
    food_id: Int
    group_id: Int
    id: Int
    name: String
    recipe_ingredient_food_candidates: recipe_ingredient_food_candidate_arr_rel_insert_input
    recipe_ingredient_group: recipe_ingredient_groups_obj_rel_insert_input
    seq_num: Int
    text: String
    units: String
}

"order by max() on columns of table \"recipe_ingredients\""
input recipe_ingredients_max_order_by {
    amount: order_by
    comment: order_by
    food_id: order_by
    group_id: order_by
    id: order_by
    name: order_by
    seq_num: order_by
    text: order_by
    units: order_by
}

"order by min() on columns of table \"recipe_ingredients\""
input recipe_ingredients_min_order_by {
    amount: order_by
    comment: order_by
    food_id: order_by
    group_id: order_by
    id: order_by
    name: order_by
    seq_num: order_by
    text: order_by
    units: order_by
}

"on conflict condition type for table \"recipe_ingredients\""
input recipe_ingredients_on_conflict {
    constraint: recipe_ingredients_constraint!
    update_columns: [recipe_ingredients_update_column!]! = []
    where: recipe_ingredients_bool_exp
}

"Ordering options when selecting data from \"recipe_ingredients\"."
input recipe_ingredients_order_by {
    amount: order_by
    comment: order_by
    food: food_order_by
    food_id: order_by
    group_id: order_by
    id: order_by
    name: order_by
    recipe_ingredient_food_candidates_aggregate: recipe_ingredient_food_candidate_aggregate_order_by
    recipe_ingredient_group: recipe_ingredient_groups_order_by
    seq_num: order_by
    text: order_by
    units: order_by
}

"primary key columns input for table: recipe_ingredients"
input recipe_ingredients_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"recipe_ingredients\""
input recipe_ingredients_set_input {
    amount: Float
    comment: String
    food_id: Int
    group_id: Int
    id: Int
    name: String
    seq_num: Int
    text: String
    units: String
}

"order by stddev() on columns of table \"recipe_ingredients\""
input recipe_ingredients_stddev_order_by {
    amount: order_by
    food_id: order_by
    group_id: order_by
    id: order_by
    seq_num: order_by
}

"order by stddev_pop() on columns of table \"recipe_ingredients\""
input recipe_ingredients_stddev_pop_order_by {
    amount: order_by
    food_id: order_by
    group_id: order_by
    id: order_by
    seq_num: order_by
}

"order by stddev_samp() on columns of table \"recipe_ingredients\""
input recipe_ingredients_stddev_samp_order_by {
    amount: order_by
    food_id: order_by
    group_id: order_by
    id: order_by
    seq_num: order_by
}

"order by sum() on columns of table \"recipe_ingredients\""
input recipe_ingredients_sum_order_by {
    amount: order_by
    food_id: order_by
    group_id: order_by
    id: order_by
    seq_num: order_by
}

"order by var_pop() on columns of table \"recipe_ingredients\""
input recipe_ingredients_var_pop_order_by {
    amount: order_by
    food_id: order_by
    group_id: order_by
    id: order_by
    seq_num: order_by
}

"order by var_samp() on columns of table \"recipe_ingredients\""
input recipe_ingredients_var_samp_order_by {
    amount: order_by
    food_id: order_by
    group_id: order_by
    id: order_by
    seq_num: order_by
}

"order by variance() on columns of table \"recipe_ingredients\""
input recipe_ingredients_variance_order_by {
    amount: order_by
    food_id: order_by
    group_id: order_by
    id: order_by
    seq_num: order_by
}

"order by aggregate values of table \"recipe_queues\""
input recipe_queues_aggregate_order_by {
    avg: recipe_queues_avg_order_by
    count: order_by
    max: recipe_queues_max_order_by
    min: recipe_queues_min_order_by
    stddev: recipe_queues_stddev_order_by
    stddev_pop: recipe_queues_stddev_pop_order_by
    stddev_samp: recipe_queues_stddev_samp_order_by
    sum: recipe_queues_sum_order_by
    var_pop: recipe_queues_var_pop_order_by
    var_samp: recipe_queues_var_samp_order_by
    variance: recipe_queues_variance_order_by
}

"input type for inserting array relation for remote table \"recipe_queues\""
input recipe_queues_arr_rel_insert_input {
    data: [recipe_queues_insert_input!]!
    "on conflict condition"
    on_conflict: recipe_queues_on_conflict
}

"order by avg() on columns of table \"recipe_queues\""
input recipe_queues_avg_order_by {
    id: order_by
    queue_id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"Boolean expression to filter rows from the table \"recipe_queues\". All fields are combined with a logical 'AND'."
input recipe_queues_bool_exp {
    _and: [recipe_queues_bool_exp!]
    _not: recipe_queues_bool_exp
    _or: [recipe_queues_bool_exp!]
    id: Int_comparison_exp
    queue_id: Int_comparison_exp
    recipe_id: Int_comparison_exp
    seq_num: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"recipe_queues\""
input recipe_queues_inc_input {
    id: Int
    queue_id: Int
    recipe_id: Int
    seq_num: Int
}

"input type for inserting data into table \"recipe_queues\""
input recipe_queues_insert_input {
    id: Int
    queue_id: Int
    recipe_id: Int
    seq_num: Int
}

"order by max() on columns of table \"recipe_queues\""
input recipe_queues_max_order_by {
    id: order_by
    queue_id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by min() on columns of table \"recipe_queues\""
input recipe_queues_min_order_by {
    id: order_by
    queue_id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"on conflict condition type for table \"recipe_queues\""
input recipe_queues_on_conflict {
    constraint: recipe_queues_constraint!
    update_columns: [recipe_queues_update_column!]! = []
    where: recipe_queues_bool_exp
}

"Ordering options when selecting data from \"recipe_queues\"."
input recipe_queues_order_by {
    id: order_by
    queue_id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"primary key columns input for table: recipe_queues"
input recipe_queues_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"recipe_queues\""
input recipe_queues_set_input {
    id: Int
    queue_id: Int
    recipe_id: Int
    seq_num: Int
}

"order by stddev() on columns of table \"recipe_queues\""
input recipe_queues_stddev_order_by {
    id: order_by
    queue_id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by stddev_pop() on columns of table \"recipe_queues\""
input recipe_queues_stddev_pop_order_by {
    id: order_by
    queue_id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by stddev_samp() on columns of table \"recipe_queues\""
input recipe_queues_stddev_samp_order_by {
    id: order_by
    queue_id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by sum() on columns of table \"recipe_queues\""
input recipe_queues_sum_order_by {
    id: order_by
    queue_id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by var_pop() on columns of table \"recipe_queues\""
input recipe_queues_var_pop_order_by {
    id: order_by
    queue_id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by var_samp() on columns of table \"recipe_queues\""
input recipe_queues_var_samp_order_by {
    id: order_by
    queue_id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by variance() on columns of table \"recipe_queues\""
input recipe_queues_variance_order_by {
    id: order_by
    queue_id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by aggregate values of table \"recipe_tags\""
input recipe_tags_aggregate_order_by {
    avg: recipe_tags_avg_order_by
    count: order_by
    max: recipe_tags_max_order_by
    min: recipe_tags_min_order_by
    stddev: recipe_tags_stddev_order_by
    stddev_pop: recipe_tags_stddev_pop_order_by
    stddev_samp: recipe_tags_stddev_samp_order_by
    sum: recipe_tags_sum_order_by
    var_pop: recipe_tags_var_pop_order_by
    var_samp: recipe_tags_var_samp_order_by
    variance: recipe_tags_variance_order_by
}

"input type for inserting array relation for remote table \"recipe_tags\""
input recipe_tags_arr_rel_insert_input {
    data: [recipe_tags_insert_input!]!
    "on conflict condition"
    on_conflict: recipe_tags_on_conflict
}

"order by avg() on columns of table \"recipe_tags\""
input recipe_tags_avg_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"Boolean expression to filter rows from the table \"recipe_tags\". All fields are combined with a logical 'AND'."
input recipe_tags_bool_exp {
    _and: [recipe_tags_bool_exp!]
    _not: recipe_tags_bool_exp
    _or: [recipe_tags_bool_exp!]
    id: Int_comparison_exp
    name: String_comparison_exp
    recipe_id: Int_comparison_exp
    seq_num: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"recipe_tags\""
input recipe_tags_inc_input {
    id: Int
    recipe_id: Int
    seq_num: Int
}

"input type for inserting data into table \"recipe_tags\""
input recipe_tags_insert_input {
    id: Int
    name: String
    recipe_id: Int
    seq_num: Int
}

"order by max() on columns of table \"recipe_tags\""
input recipe_tags_max_order_by {
    id: order_by
    name: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by min() on columns of table \"recipe_tags\""
input recipe_tags_min_order_by {
    id: order_by
    name: order_by
    recipe_id: order_by
    seq_num: order_by
}

"on conflict condition type for table \"recipe_tags\""
input recipe_tags_on_conflict {
    constraint: recipe_tags_constraint!
    update_columns: [recipe_tags_update_column!]! = []
    where: recipe_tags_bool_exp
}

"Ordering options when selecting data from \"recipe_tags\"."
input recipe_tags_order_by {
    id: order_by
    name: order_by
    recipe_id: order_by
    seq_num: order_by
}

"primary key columns input for table: recipe_tags"
input recipe_tags_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"recipe_tags\""
input recipe_tags_set_input {
    id: Int
    name: String
    recipe_id: Int
    seq_num: Int
}

"order by stddev() on columns of table \"recipe_tags\""
input recipe_tags_stddev_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by stddev_pop() on columns of table \"recipe_tags\""
input recipe_tags_stddev_pop_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by stddev_samp() on columns of table \"recipe_tags\""
input recipe_tags_stddev_samp_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by sum() on columns of table \"recipe_tags\""
input recipe_tags_sum_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by var_pop() on columns of table \"recipe_tags\""
input recipe_tags_var_pop_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by var_samp() on columns of table \"recipe_tags\""
input recipe_tags_var_samp_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"order by variance() on columns of table \"recipe_tags\""
input recipe_tags_variance_order_by {
    id: order_by
    recipe_id: order_by
    seq_num: order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input recipes_append_input {
    extraction_metadata: jsonb
}

"Boolean expression to filter rows from the table \"recipes\". All fields are combined with a logical 'AND'."
input recipes_bool_exp {
    _and: [recipes_bool_exp!]
    _not: recipes_bool_exp
    _or: [recipes_bool_exp!]
    created_at: timestamptz_comparison_exp
    extraction_metadata: jsonb_comparison_exp
    id: Int_comparison_exp
    image: String_comparison_exp
    name: String_comparison_exp
    recipe_direction_durations: recipe_direction_durations_bool_exp
    recipe_directions: recipe_directions_bool_exp
    recipe_ingredient_groups: recipe_ingredient_groups_bool_exp
    recipe_queues: recipe_queues_bool_exp
    recipe_tags: recipe_tags_bool_exp
    source: String_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input recipes_delete_at_path_input {
    extraction_metadata: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input recipes_delete_elem_input {
    extraction_metadata: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input recipes_delete_key_input {
    extraction_metadata: String
}

"input type for incrementing numeric columns in table \"recipes\""
input recipes_inc_input {
    id: Int
}

"input type for inserting data into table \"recipes\""
input recipes_insert_input {
    created_at: timestamptz
    extraction_metadata: jsonb
    id: Int
    image: String
    name: String
    recipe_direction_durations: recipe_direction_durations_arr_rel_insert_input
    recipe_directions: recipe_directions_arr_rel_insert_input
    recipe_ingredient_groups: recipe_ingredient_groups_arr_rel_insert_input
    recipe_queues: recipe_queues_arr_rel_insert_input
    recipe_tags: recipe_tags_arr_rel_insert_input
    source: String
    updated_at: timestamptz
}

"input type for inserting object relation for remote table \"recipes\""
input recipes_obj_rel_insert_input {
    data: recipes_insert_input!
    "on conflict condition"
    on_conflict: recipes_on_conflict
}

"on conflict condition type for table \"recipes\""
input recipes_on_conflict {
    constraint: recipes_constraint!
    update_columns: [recipes_update_column!]! = []
    where: recipes_bool_exp
}

"Ordering options when selecting data from \"recipes\"."
input recipes_order_by {
    created_at: order_by
    extraction_metadata: order_by
    id: order_by
    image: order_by
    name: order_by
    recipe_direction_durations_aggregate: recipe_direction_durations_aggregate_order_by
    recipe_directions_aggregate: recipe_directions_aggregate_order_by
    recipe_ingredient_groups_aggregate: recipe_ingredient_groups_aggregate_order_by
    recipe_queues_aggregate: recipe_queues_aggregate_order_by
    recipe_tags_aggregate: recipe_tags_aggregate_order_by
    source: order_by
    updated_at: order_by
}

"primary key columns input for table: recipes"
input recipes_pk_columns_input {
    id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input recipes_prepend_input {
    extraction_metadata: jsonb
}

"input type for updating data in table \"recipes\""
input recipes_set_input {
    created_at: timestamptz
    extraction_metadata: jsonb
    id: Int
    image: String
    name: String
    source: String
    updated_at: timestamptz
}

input search_foods_args {
    search: String
}

"Boolean expression to compare columns of type \"timestamp\". All fields are combined with logical 'AND'."
input timestamp_comparison_exp {
    _eq: timestamp
    _gt: timestamp
    _gte: timestamp
    _in: [timestamp!]
    _is_null: Boolean
    _lt: timestamp
    _lte: timestamp
    _neq: timestamp
    _nin: [timestamp!]
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
    _eq: timestamptz
    _gt: timestamptz
    _gte: timestamptz
    _in: [timestamptz!]
    _is_null: Boolean
    _lt: timestamptz
    _lte: timestamptz
    _neq: timestamptz
    _nin: [timestamptz!]
}

"Boolean expression to compare columns of type \"tsvector\". All fields are combined with logical 'AND'."
input tsvector_comparison_exp {
    _eq: tsvector
    _gt: tsvector
    _gte: tsvector
    _in: [tsvector!]
    _is_null: Boolean
    _lt: tsvector
    _lte: tsvector
    _neq: tsvector
    _nin: [tsvector!]
}


scalar float8

scalar food_data_type_enum

scalar jsonb

scalar timestamp

scalar timestamptz

scalar tsvector